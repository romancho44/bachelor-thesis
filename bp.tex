% preambule dokumentu
\documentclass[twoside, 12pt]{article}
\usepackage{bakalarska-prace/xdipp,xltxtra,polyglossia,graphicx,listings,color}
\usepackage[htt]{hyphenat}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

% styly pro sazbu java kódu
\lstset{
frame=tb,
language=Java,
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
basicstyle={\small\ttfamily},
numbers=none,
numberstyle=\tiny\color{gray},
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=true,
breakatwhitespace=true,
tabsize=3,
inputencoding=utf8/latin1,
extendedchars=true,
literate=
{á}{{\'a}}1
{í}{{\'i}}1
{é}{{\'e}}1
{ý}{{\'y}}1
{ú}{{\'u}}1
{ó}{{\'o}}1
{ě}{{\ˇ{e}}}1
{š}{{\ˇ{s}}}1
{č}{{\ˇ{c}}}1
{ř}{{\ˇ{r}}}1
{ž}{{\ˇ{z}}}1
{ď}{{\ˇ{d}}}1
{ť}{{\ˇ{t}}}1
{ň}{{\ˇ{n}}}1
{ů}{{\r{u}}}1
{Á}{{\'A}}1
{Í}{{\'I}}1
{É}{{\'E}}1
{Ý}{{\'Y}}1
{Ú}{{\'U}}1
{Ó}{{\'O}}1
{Ě}{{\ˇ{E}}}1
{Š}{{\ˇ{S}}}1
{Č}{{\ˇ{C}}}1
{Ř}{{\ˇ{R}}}1
{Ž}{{\ˇ{Z}}}1
{Ď}{{\ˇ{D}}}1
{Ť}{{\ˇ{T}}}1
{Ň}{{\ˇ{N}}}1
{Ů}{{\r{U}}}1
}

\setdefaultlanguage{czech}
\begin{document}
\pagestyle{headings}

\def\typprace{Bakalářská}

% uvodni cast bakalářské prace
\titul{Implementace backendových modulů a~následné navržení a~implementace modulu timeline pro potřeby gamifikovaného informačního systému}
{Roman Vozka}{Ing. Jan Kolomazník, Ph.D.}{Brno, 2020}


\podekovani{Rád bych touto formou poděkoval vedoucímu mé bakalářské práce Ing. Janu Kolomazníkovi, Ph.D.
za poskytované konzultace a přínosné rady. Dále celému vývojovému týmu za jejich nasazení a poskytnutou možnost
se na tomto projektu podílet. V neposlední řadě patří velké díky mé rodině.}

\prohlasenimuz{Brno, 1. května 2020}


\abstract{Vozka R. Implementation of backend modules and subsequent design and implementation of module Timeline for needs of Gamified Information System. Brno, 2020}
{Thesis describes implementation of backend modules for the web application of Gamified Information System.
In the thesis are introduced concepts and technologies of web, concept of gamification and interestingness of its application
to the information system. With the use of this concepts backend modules has been created.}

\par

\keywords{Backend, Gamification, Information System, Spring Framework, REST, Web Technologies}

\abstrakt{Vozka R. Implementace backendových modulů a~následné navržení a~implementace modulu timeline pro potřeby gamifikovaného informačního systému. Brno, 2020}
{Práce pojednává o implementaci backendoých modulů pro webovou aplikaci gamifikovaného informačního systému.
V práci jsou představeny nejrůznější pojmy a technoligie z oblasti webových technologíí, pojem gamifikace a zajímavost
jejího provázání s informačním systémem. S využitím těchto poznatků byly vytvořěny backendové moduly.}

\par

\klslova{backend, gamifikace, informační systém, Java, Spring Framework, REST, webové technologie}

\obsah

\listoffigures

\listoftables

\cislovat{2}

% jednotlive kapitoly dokumentu

\kapitola{Úvod a~cíl}

Pro zpracování své bakalářské práce
jsem se rozhodl připojit do vývojového týmu firmy Gamifika s.r.o.,
který vyvíjí gamifikovaný informační systém
pro kariérní růst spolupracovníků firmy Optimal Energy,
společnosti poskytující energetické poradenství.
Ve vývojovém týmu zaujímám funkci backendového vývojáře
a~již druhým rokem se podílím na vývoji backendu webové aplikace informačního systému.
K~projektu jsem se připojil ve fázi, kdy se utvářely základy pro vývoj
a~navrhovaly se jednotlivé části gamifikovaného informačního systému.


Cílem projektu je vytvoření snadno ovladatelného poutavého systému
pro podporu pracovního nasazení, motivace a~rozvoje pracovníků.
Přidanými hodnotami vytvářeného systému pro firmu Optimal Energy
by mělo být předání vize a~hodnot nováčkům, snížení retence,
efektivnější zavádění nových firemních procesů
a~dynamičtější růst struktur ve firmě.


Pro nové zaměstnance by měl systém sloužit
jako kapesní průvodce pro nastartování kariéry ve firmě.
Systém by se měl stát ideálním nástrojem pro zapracování
a~plnění pracovních úkolů.
Novým zaměstnancům poskytne interaktivní trénink obchodních dovedností,
přístup do znalostní báze a~tvorbu užitečných návyků.


Jak již může být z~názvu práce zřejmé, tak se tato bakalářská práce
zabývá především implementací určitých bakendových modulů webové aplikace
gamifikovaného informačního systému, cílem je tedy samotná implementace.


Nejdříve je v~práci představen pojem gamifikace se
zajímavostí aplikace tohoto odvětví na informační systém.
Následně se může čtenář v~částí literárního přehledu
ve stručnosti seznámit se základními pojmy,
týkajících se vývoje webových aplikací a~dozvědět se určité informace o~nástrojích a~technologiích,
které používáme při vývoji backendových modulů informačního systému.

V~kapitole vlastní práce je výsledně popsán samotný vývoj a~funkcionalita
vybraných částí modulů s~využitím představených technologií
a~to především programovacího jazyka Java s~využitím frameworku Spring.


\kapitola{Rešerše gamifikace}

Snahou procesu gamifikace je zasazení herních mechanismů a~principů,
které ve hrách dobře fungují, do neherního prostředí.
V~gamifikaci je kladen největší důraz na motivaci člověka.

% motivace v~gamifikovaných systémech
Jednou z~hlavních myšlenek je tedy optimalizace motivace lidí
v~rámci určitého systému, na rozdíl od striktního zaměření na výkonnost.
Většina systémů je zaměřena především na plnění určitých funkcí
a~jsou navrženy tak, aby byla vykonávaná práce hotova, co možná nejrychleji.


Existují systémy, které se na druhou stranu zaměřují spíše na lidi,
jejich potřeby, pocity a~důvody, proč nechtějí nebo naopak chtějí dělat určité věci.
Tyto systémy se snaží u~lidí více rozvíjet jejich zapojování do procesů
a~zapálení pro věc.

Herní průmysl je oblastí, která cílí hlavně na lidi a~snaží se je
co nejvíce zaujmout, zabavit a~naplnit jejich potřeby.
Právě z~těchto důvodů je uplatnění těchto principů nazýváno gamifikace (od angl. slova game).
Hlavním účelem her je potěšit hráče, který ji hraje. \cite{octalysis}

\sekce{Gamifikační framework Octalysis}

Jedním z~význačných a~uznávaných lidí zabývající se gamifikací je Yu Kai Chou,
který na základě jeho letitých zkušeností v~této oblasti vytvořil gamifikační
framework nazvaný Octalysis pro analýzu toho, co činí různé herní i~neherní systémy
zábavnými.

Pojmový rámec Octalysis
\footnote{Blog autora o~gamifikačním frameworku Octalysis:
https://yukaichou.com/gamification-examples/octalysis-complete-gamification-framework}
je postavený na myšlence toho,
že jsou hry zábavné, protože bývají postavené na určitých základních principech,
které nás motivují ke specifickým činnostem.
Dle Yu-kai Choua nás různé typy herních technik posouvají určitým směrem.
Některé mají inspirační a~umocňující efekt,
zatímco jiné se snaží s~hráči spíše manipulovat,
což může vést až k~posedlosti.
Analytický nástroj Octalysis byl navržen tak,
aby bylo možné odlišit různe druhy motivace lidí.

\clearpage

Gamifikační framework Octalysis byl vytvořen jako osmihran reprezentující
8 různých motivačních principů na každé straně.

\obrazek
\vlozobr{bakalarska-prace/oktalyza}{0.18}
\endobr{Zjednodušený diagram gamifikačního frameworku Octalysis
\obrzdroj{Yu-kai Chou, Octalysis, upraveno}}


% 1 smysl, význam, poslání
Smysl či poslání je motivačním principem, při kterém hráči
věří, že dělají něco významnějšího než jsou oni sami nebo
byli vybráni pro konání nějakého vyššího dobra.
Příkladem mohou být i~lidé, kteří věnují spoustu času správou nějakého
fóra, případně tvorbě věcí pro celou komunitu jako třeba u~Wikipedie nebo
celé řady open source projektů.
V~souvislosti s~tímto přístupem bývá někdy uplatňováno
i~takzvané štěstí začátečníka, jako efekt, kdy lidé věří,
že byli obdarování něčím vzácným co kupříkladu u~her jiní hráči nevlastní.

% 2 rozvoj, vylepšování vlastností, pokrok
Motivační princip seberozvoje čerpá z~pokroku, rozvíjení dovedností
a~eventuálně z~překonávání různých výzev.
Velice motivační ve hrách bývají právě výzvy,
pokud za ně hráči získavají určité trofeje nebo odměny.
Systémy odměn a~výzev, různé bodovací systémy a~žebříčky
jsou poměrně lehko implementovatelné,
proto je využívá mnoho herních i~neherních systémů.

% 3 zplnomocnění, kreativita, zpětná vazba
Dalším motivačním procesem je zplnomocnění člověka v~rámci nějakého kreativního procesu.
U tohoto procesu musí hráči opakovaně přicházet s~novými
nápady a~zkoušet různé kombinace. Poskytnutí prostoru pro vyjádření
kreativity a~možnosti vidět své výsledky, společně se získáním zpětné vazby
a~možností na ně reagovat je pro mnoho lidí zábavné.
Příkladem může být hraní se stavebnicí nebo malování,
což jsou činnosti, které má spousta lidí v~oblibě a~jsou pro ně zábavné sami o~sobě.
Tyto myšlenky uplatňuje mnoho herních vývojářů,
díky čemuž nutně nemusejí pravidelně produkovat nový herní obsah
a~přesto jimi vyvinuté herní aktivity mohou být pro uživatele dlouhodobě svěží a~poutavé.

% 4 vlastnictví, majetek
Možnost vlastnit či sbírat určité věci, ikdyž třeba jen virtuální,
přináší mnohým uživatelům příjemný pocit a~podporuje jejich lačnost
sytém dále používat. Jedná se tak o~další významný, motivační a~táhnoucí mechanismus.
Rozvíjení majetku či vlasnictví vychází z~lidské přirozenosti,
a~proto mnozí hráči chtějí ve hrách získávat nové předměty
a~budovat své bohatství.

% 5 Sociální vliv
Dobře známým hnacím faktorem je vliv sociální.
K~tomuto vlivu se řadí kupříkladu sociální přijetí, soutěživost, mentorství,
přátelství a~také závist. Poměrně velký efekt působící na hráče různých her
má, když vidí jiného hráče velice dobrého v~určité činnosti.
To umocňuje snahu různých hráčů více vykonávat nějakou činnost a~zlepšovat se v~ní.
Spousta firem v~dnešních dnech klade relativně velký důraz na optimalizaci
jejich socílních průzkumů a~strategií.

% 6 Nouze a~netrpělivost
Další strana osmihranu frameworku Octalysis pozoruje využití
netrpělivosti lidí. Spousta systémů pracuje s~netrpělivostí
prostřednictvím dynamik využívajících časové termíny.
Hra či aplikace nabídne uživateli určitou věc, která je však uživateli
odemčena až po určité stanovené lhůtě, například po 2 hodinách.
U~některých lidí tato dynamika vyvolává potřebu na danou věc neustále myslet
a~kontrolovat její přístupnost, což vede k~častějšímu používání systému.
U~uživatelů takto narůstá zájem o~určitou oblast, už jen z~principu,
že byli na ni nuceni tak „dlouho“ čekat.

% 7 Nepředvídatelnost a~zvědavost
Když nelze předpokládat, co se stane, jsme nuceni o~tom přemýšlet častěji a~
hledáme různé všemožné varianty, které by mohly nastat.
Právě díky tomuto napětí, které nepředvídatelnost přinaší se spousta lidí
dívá na filmy nebo čte různé příběhy.
Na principech nepředvídatelnosti a~náhody jsou však postaveny i~hazardní hry,
které v~lidech vyvolávají zvědavost a~napětí.
Spousta sytémů s~výhodou využívá možnosti navodit pocit napětí
a~vzbudit u~uživatelů zvědavost,
obvykle nějakou formou loterijního programu.

% 8 Strach ze ztráty
Poslední táhlo motivace využívá strachu uživatelů ze ztráty určitých příložitostí
a~možností či nabytých statků nejrůznějšího rázu.
Uplatnění těchto taktik bývá hojně u různých her na internetu,
například když se hráč ve hře stará o různá zvířata.
Po určitém časovém limitu, pokud hráč nenakrmí svou virtuální zvěř,
se může stát, že zvířátko uhyne.
Dalším principem je poskytování různých příložitosti,
které však uživatelé mohou navždy ztratit,
pokud na ně ihned nezareagují.
Těmito způsoby systémy vyvíjejí na uživatele poměrně velký tlak
a~spousta z~nich o~nejrůznější přílěžitosti či vydobyté statky nechce přijít,
proto se pro ně jeví nezbytné, se určitým činnostem více věnovat.


Cílem gamifikace je lidi motivovat,
pomoci jim ke splnění jejích cílů, ať už jsou to cíle kariérní, studijní či osobní.
Ohodnocení a~status, který hráči v~průběhu hraní získávají,
pomáhají ke sledování jejich průběžného postupu.
Tyto mechaniky podporují osobní cestu k~jejich seberozvoji.
Gamifikace se dnes již uplatňuje v~nejrůznějších odvětvích,
například pro vzdělávání, firemní rozvoj nebo marketing.


\sekce{Podniková gamifikace}

Jelikož se firmy snaží využívání lidských zdrojů zefektivnit co nejvíce,
někdy bývá nápor na zaměstnance velice kritický.
Gamifikace se tak stává rostoucím trendem pro podporu pracovních výkonů
a~motivaci zaměstnanců.
Podniková gamifikace využívá prvků herního designu a~snaží se
je implementovat do~neherního podnikového prostředí.
Gamifikace využívaná ve firmách
má mnoho podob a~ve své podstatě se používá napříč různými průmysly.
V~korporátním světě může zvýšit motivaci zaměstnanců, generovat nápady a~podporovat inovace.
Pro mnoho firem to může být ten pravý nástroj, jak zvýšit angažovanost zaměstnanců
a~podpořit jejich nadšení z~práce.

\par
% Příklad použití
Zaměstnanci se například formou hraní deskové hry, vytvořené na základě firemních pochodů,
poutavou a~zábavnou formou seznamují s~pracovištěm, dalšími zaměstnanci,
významem jednotlivých oddělení,
přičemž si z~takovéto hry odnášejí cenné zkušenosti, které dále v~praxi mohou využít.

\par

Populární způsoby aplikace gamifikace na pracoviště zahrnují: vzdělávací aktivity,
tréninková sezení, rozvíjení schopností zaměstnanců a~v~neposlední řadě i~motivaci.

Gamifikace používá psychologii a~průzkumy lidského chování k~tomu,
aby správně zacílila a~zapůsobila na publikum,
kterému se následně dle jeho potřeb budou vytvářet herní prvky na míru.

\sekce{Gamifikované aplikace a~systémy}

Gamifikovaný software je jakýkoliv nástroj nebo platforma používaná s~uplatňováním herních mechanik,
s~cílem posílit angažovanost a~úspěšné výsledky.
Běžné případy užití zahrnují oddanost zákazníka, e-learning, motivaci zaměstnanců a~měření výkonnosti.

\par

Volně dostupnými populárními gamifikovanými aplikacemi
jsou například Habitica, Epic Win, nebo LifeRPG.
Tyto aplikace umožňují uživatelům (hráčům) vytvářet si vlastní úkoly,
za jejichž splnění pak získávají odměny ve formě zkušenostních bodů,
penízků nebo různých dovednostních bodů.
Na základě těchto bodů pak uživatel prostřednictvím grafického rozhraní přehledně vidí,
jak se zlepšuje a~rozvíjí si své dovednosti.

\par

Například webová a~mobilní aplikace Habitica se snaží u~hráčů vytvořit dobré návyky
a~naopak jim pomáha se zbavováním těch špatných.
V~případě, že hráč rozvíjí své dobré návyky,
získává zkušenostní body a~herní měnu,
pakliže dělá ty špatné, ztrácí body zdraví.
Uživatel si může vytvářet různé seznamy úkolů,
které potřebuje v~běžném i~pracovním životě řešit,
ty pak může například dle věcnosti seskupovat do určitých kategorií.
Aplikace nabízí nejrůznější nastavení pro úkoly, například upozorňování, dobu splnění, náročnost úkolu.
Habitica hojně podporuje služby pro spolupráci s~jinými hráči. Lze vytvářet družiny,
ve kterých hráči mohou společně společně plnit úkoly nebo výzvy.
Za herní měnu si hráči mohou pořizovat pro svou postavu nejrůznější předměty,
které jim v~herním světě nějakým způsobem pomáhají.
Aplikace nabízí možnost chatování s~hráči z~družiny, případně i~ve veřejných chatovacích skupinách.

\par

U~mobilní aplikace Epic Win si hráč vytváří seznam úkolů,
ke kterým přiřazuje důležitost a~případně dovednost.
Plněním těchto úkolů hráč rozvíjí své dovednosti
a získává zkušenostní body,
čímž zvyšuje úroveň své postavy.
Uživatelova postava se postupně posouvá po cestě,
která je graficky vizualizována na herní mapě.
Během putování touto cestou hráč průběžně nalézá
různé herní předměty, kterými rozšiřuje svou sbírku trofejí.
Tato aplikace se snaží zaujmout jednoduchostí a zajímavým grafickým zpracováním.

\par

Vývojem mobilní aplikace s~prvky gamifikace se v~rámci bakalářské práce zabýval Pavol Podstrelený (2018).
Jeho práce se zabývá gamifikací, motivací a~typologií hráčů, dále pak samotným vývojem mobilní aplikace.
Uživatelé plní různé úlohy, například matematické, za jejichž splnění získávají body a~odznaky.
Důraz byl kladen především na grafické zpracování a~barevné rozlišení jednotlivých pracovních prvků.
K~vývoji aplikace byl použit programovací jazyk Kotlin.

\par

Co se spojení gamifikace a~podnikových aplikací či informačních systémů týče jsem nalezl především systémy,
které zahrnovaly z~gamifikace prvky především pro bodování zaměstnanců, statistické ukazatele výkonnosti, žebříčky, úspěchy, odznaky.
Příkladem integrace gamifikovaných prvků do podnikových aplikací je gamifikovaný modul od společnosti SAP, SAP Cloud Platform Gamification,
který je možné začlenit do existující či nové podnikové aplikace.
SAP Cloud Platform Gamification nabízí koncepty jako je bodování,
odznaky, mise a analýzy, které zaměstnanec vidí přehledně na přehledovém panelu.

\par
% příběh? možná spíš širší kontext, styl?
% U~žádného z~těchto softwarových řešení jsem však nenašel příběh,
% který by hráče do používání aplikace více vtáhnul.
Do námi vyvíjeného systému se budeme snažit zakomponovat poutavý příběh,
který bude zahrnovat mise, což jsou větší celky úkolů, které budou hráči plnit.
Pro vývoj našeho systému považujeme příběh za velmi důležitou část,
protože se od něj bude odvíjet grafické zpracování uživatelského rozhraní.
Chceme, aby toto uživatelské rozhraní hráče na první pohled upoutalo
a jeho ovladatelnost byla velice intuitivní a~jednoduchá.

\par
% Teď už ne! Odkázat se na M.B. a~D.D.
% V~rámci závěrečných prací jsem dosud neobjevil žádnou práci,
% která by se zabývala propojení podnikového systému či informačního systému s~gamifikací.

\kapitola{Literární přehled}

V~této kapitole jsou popsány stěžejní pojmy a~technologie použité pro vývoj webové aplikace
gamifikovaného informačního systému.

\sekce{Systém WWW}
Webové aplikace fungují na základě systému WWW (World Wide Web).
Systém WWW  poskytuje komunikaci typu klient -- server (Obrázek 2)
prostřednictvím následujících základních složek:

\begin{itemize}
\item komunikačního protokolu \texttt{HTTP},
\item jednoznačné globální identifikace WWW zdrojů (URL, URI, URN),
\item standardního jazyka pro vytváření a~publikaci WWW zdrojů/dokumentů -- \texttt{HTML}
(HyperText Markup Language).
\end{itemize}

\obrazek
\vlozobr{bakalarska-prace/client-server.jpg}{0.8}
\endobr{Komunikace typu klient -- server
\obrzdroj{Zakresleno pomocí volně dostupného nástroje \texttt{draw.io}}}

% HTTP
\texttt{HTTP} je základem webového systému.
Jedná se o~jednoduchý síťový protokol aplikační vrstvy,
který pro přenos dat využívá protokol \texttt{TCP}.
Je založený na principu klient -- server,
což znamená, že jsou zprávy ve formě požadavků a~odpovědí vyměňovány mezi klientem
a~serverem.

% HTTP Response, MIME
\texttt{HTTP} odpovědi byly původně textové dokumenty ve tvaru \texttt{HTML}.
Nyní, díky podpoře \texttt{MIME} (Multipurpose Internet Mail Extensions),
mohou obsahovat soubory různých i~netextových formátů.
\texttt{MIME} je tedy standard pro specifikaci internetového média (zdroje).
Hlavičky \texttt{MIME} jsou součástí záhlaví \texttt{HTTP} zpráv, např.: \texttt{Content-type:~application/json.}

\textbf{Uniform Resource Locator} (URL) je typ URI -- identifikátoru přístupu k~internetovému zdroji.
Formát URL pro protokol HTTP:
\footnote{Přednaška z~předmětu Počítačové~sítě I: Systém WWW, 2017}

\bigskip
\texttt{http://<host>[:<port>][<abs\_path>[?<query>][\#<fragment>]]}

\bigskip

\noindent{Adresa URL je složena z~následujících 2 složek:

\begin{itemize}
\item \textbf{Hierarchická složka} -- vyjadřuje cestu k~webovému objektu
\item \textbf{Nehierarchická složka} -- obsahuje volitelné položky:
\begin{itemize}
\item \textbf{Query} -- hodnoty předávané ke zpracování webovým aplikacím jako parametr \texttt{QUERY\_STRING}.
\item \textbf{Fragment} -- odkaz na identifikátor, kterým je označena určitá část webového objektu
\end{itemize}
\end{itemize}

\sekce{Webové aplikace}

Webové aplikace jsou sofistikované systémy, které jsou ve většině případů
používané prostřednictvím webového prohlížeče.
Na webový prohlížeč a~internet je možné v~tomto kontextu pohlížet jako na prostředí
pro provoz webové aplikace. Pro přenos dat mezi klientem a~serverem je využíván protokol \texttt{HTTP}.
Přenášené data mohou obsahovat kusy kódu,
které jsou interpretovány na straně klienta pomocí programovacího jazyka \texttt{JavaScript}.

Nespornou výhodou webových aplikací je, že nemusí být instalované na uživatelově počítači.
Jediné, co uživatel pro spuštění a~provoz webové aplikace potřebuje, je webový prohližeč.
Tato vlastnost je činí velice přístupnými. Na druhé straně však webové aplikace nemohou
využít plnou funkcionalitu počítače, pakliže to webový prohlížeč neumožňuje.

Pro vývoj webových aplikací neexistuje žádná obecná technika,
která by se dala brát jako určité paradigma.
Exisují různé osvědčené postupy,
které však mohou být protichůdné a~nebo jsou vhodné pouze za určitých podmínek.

% TODO: formy webových aplikací
Exitují různé formy webových aplikací,
přičemž každá z~nich může být jinak vhodná na určité úkony.

Webové aplikace jsou obvykle psány ve více programovacích jazycích,
které se liší mezi backendem a~frontendem,
což jsou 2 hlavní části webových aplikací.
\cite{odinuv}



\sekce{Architektura MVC}
Někdy bývá u~webových aplikací uplatňován architektonický vzor \texttt{Model-View-Controller} (\texttt{MVC}),
který rozděluje aplikaci do tří hlavních logických komponent (\texttt{model}, \texttt{view}, \texttt{controller}).
Každá z~těchto komponent je vytvořena za účelem zpracování specifických aspektů aplikace.
Architektura \texttt{MVC} je jednou z~nejvíce používaných standardů při vývoji
škálovatelných a~rozšiřitelných webových aplikací.
\cite{tutorialspointMvc}

Komponenta \texttt{model} reprezentuje datový oddíl aplikace.
Tato komponenta obvykle pracuje s~databází a~na základě požadavků
data různě zpracovává, odesílá, ukládá či transformuje.

Komponenta \texttt{view} je hlavní vykreslovací komponentou, se kterou interaguje uživatel.
Poskytuje veškerou logiku uživatelského rozhraní aplikace,
zahrnujíc veškeré komponenty uživatelského rozhraní jako jsou formuláře, tlačítka
atd.

Komponenta \texttt{controller} poskytuje rozhraní mezi dvěma zmíněnými komponentami
model a~view. Zpracovává veškerou podnikovou logiku aplikace.
Typicky na základě obdržených požadavků od uživatele, zprostředkovaných komponentou
\texttt{view}, manipuluje s~daty prostřednictvím komponenty \texttt{model} a~v~závěru odesílá
odpověď zpět komponentě \texttt{view}, která výsledek vykreslí uživateli.


\sekce{Frontend}

\texttt{Frontend} je to, co vidí uživatel ve webovém prohlížeči.
Obvykle se jedná o~webovou stránku, která je zobrazována uživateli prostřednictvím
technologií \texttt{HTML}, \texttt{CSS}, \texttt{JavaScript} a~různého mediálního obsahu (obrázky, videa atd.).
V~dnešní době je hojně využíván \texttt{JavaScript}, který z~frontendu utváří samostatnou aplikaci.

Pro první verzi frontendu webové aplikace byl využiván \texttt{TypeScript}
s~použitím frameworku \texttt{Angular},
tyto technologie jsou popsány v~diplomové práci Ing. Martina Bendíka.
Pro druhou verzi webové aplikace, která je aktuálně vyvíjena,
používáme \texttt{JavaScript} s~použitím frameworku \texttt{Polymer}.

\sekce{Backend}


Pod pojmem \texttt{backend} si můžeme představit téměř všechno běžící na serveru,
případně více serverech, potřebného pro provoz a~fungování webových aplikací.
\cite{odinuv}
\par
\texttt{Bakend} je souhrn funkcionalit zodpovědných za manipulaci dat,
podnikovou logiku, zabezpečení, komunikaci s~jinými aplikacemi atd.

Práce se zabývá implementací určitých \texttt{backendových modulů} webové aplikace informačního systému.
Pod \texttt{backendovým modulem} si můžeme představit aplikaci
poskytující výše uvedenou funkcionalitu a~to především manipulaci, správu a~přenos dat.
Pro implementaci těchto modulů byl použit programovací jazyk \texttt{Java} s~využitím frameworku \texttt{Spring}.
Obě technologie jsou více představeny a~popsány ve stejnojmenných samostatných sekcích této kapitoly.

\sekce{Webové služby}

Webová služba je druh webové aplikace typicky poskytované prostředncitvím \texttt{HTTP}. \cite{kalin}
Webová služba je tedy distribuovaná aplikace, jejíž komponenty lze nasadit a~spustit na různých zařízeních.

Klientem webové služby je ve většině případů jiná aplikace, namísto webového prohlížeče.
Klientská aplikace může být napsána v~jakémkoliv jazyce, který podporuje
odpovídající knihovny pro webové služby.
Koncepce webových služeb klade vysoký důraz na jazykovou průhlednost,
to znamená, že poskytovatel a~příjemce služby nemusejí být napsáni
ve stejném programovacím jazyce.
% interoperabilita
Jazyková průhlednost je klíčem k~ interoperabilitě,
schopnosti webových služeb hladce fungovat napříč různými systémy,
navzdory rozdílům v~programovací jazycích,
podporovaných knihovnách a~platformách.

Několik funkcí odlišuje webové služby od distibuovaných systémů: otevřená infrastruktura,
jazyková průhlednost a~modulární desgin.
Webové služby mohou být rozděleny do dvou skupin, na SOAP-ově založené a~RESTové.

\sekce{SOAP -- Simple Object Access Protocol}

Zjednodušeně je \texttt{SOAP} určitý dialekt \texttt{XML}
(EXtensible Markup Language), ve kterém je zapsána zpráva do \texttt{XML} dokumentu.
\texttt{SOAP} bývá někdy zaměňován za \texttt{SOA} (Service Oriented Architecture) protokol,
který je více popsán níže v této kapitole.
SOAPově založenou službu poskytovanou prostřednictvím protokolu \texttt{HTTP}
je možné brát i~jako speciální případ služby RESTové.
\cite{kalin}

\sekce{REST -- Representational State Transfer}

\texttt{REST} sám o~sobě není architekturou. REST je množina omezení,
které při aplikování na návrh systému, utvářejí určítý architektonický styl.
\cite{sandoval}

\bigskip

\noindent{Dle Sandovala jsou pravidla definující RESTový systém následující:}
\begin{itemize}
\item Musí se jednat o~systém typu klient-server.
\item Sytém musí být bezstavový -- nemělo by být potřebné udržovat sezení, každý požadavek by měl být nezávislý na ostatních.
\item Měl by podporovat systém ukládání do mezipaměti -- síťová infrastruktura by měla podporovat mezipaměť na různých úrovních.
\item Musí být jednotně přístupný -- každý zdroj musí mít unikátní adresu a~validní přístupový bod.
\item Musí být vrstvený -- musí podporovat škálovatelnost.
\end{itemize}

\noindent{RESTový systém může být implementován v~jakékoliv dostupné síťové architektuře.}


% bezstavovost
Systémy, které se řídí paradigmatem REST jsou bezstavové, což znamená,
že server nemusí vědět nic o~tom, v~jakém stavu je klient a~naopak.
Tímto způsobem mohou server i~klient porozumět  jakékoliv přijaté zprávě,
aniž by viděli zprávy předchozí.
\cite{codecademyRest}

% SOA - Mikroslužby
\sekce{Servisně orientovaná architektura (SOA)}
Servisně orientovaná architektura je styl softwarového návrhu,
kde jsou služby aplikačních komponent poskytovány jiným komponentám
prostřednictvím komunikačního protokolu po síti.

Služba je v~rámci servisně orientované architektury jednotkou funkcionality,
ke které lze přistupovat vzdáleně z~jiné aplikace.
Tato služba je schopna fungovat nezávisle a~také je možné ji nezávisle upravovat.

\bigskip

\noindent{Vlastnosti služby servisně orientované architektury:}

\begin{itemize}

\item Logicky reprezentuje podnikovou činnost se specifikovaným výstupem.

\item Je samostatná.

\item Je černou skříňkou pro příjemce, což znamená,
že příjemci nemusí být známo vnitřní fungování služby.

\item Může se skládat z~jiných podslužeb.

\end{itemize}

Různé služby mohou být spojeny pro poskytnutí funkcionality velké softwarové aplikace,
tento princip \texttt{SOA} sdílí s~přístupem modulárního programování.
Servisně orientovaná architektura integruje distribuované,
odděleně spravované a~nasazené komponenty softwarového systému.
Tato integrace je umožněna technologiemi a~standardy, které usnadňují
komunikaci komponent a~spolupráci v~síti.

\texttt{SOA} je spojena s~myšlenkou aplikačního programového rozhraní
(application programming interface -- \texttt{API}), komunikačního protokolu mezi
různými částmi počítačového systému určeného pro zjednodušení implementace,
údržby a~komunikace jednolivých částí systému.
Toto \texttt{API} umožňuje provoz jednotlivých služeb.
%(en.wikipedia.org, 2020)

\sekce{Programovací jazyk Java}
% úvod
V~této sekci se pokusím lehce představit programovací jazyk \texttt{Java},
poukázat na jeho silné stránky
a~vysvětlit důvod, proč byl pro implementaci bakendových aplikací
gamifikovaného informačního systému zvolen.

Java je univerzální objektově orientovaný programovací jazyk.
Byla navržena tak, aby byly v~ní napsané programy spustitelné na nejrůznějších platformách.
Zkompilovaný kód Javy lze spustit na všech platformách, které Javu podporují,
aniž by bylo nutné zdrojové java kódy opětovně kompilovat.
Java aplikace jsou obvykle kompilovány do \texttt{byte-kódu},
který může být uveden do chodu na jakémkoliv Java virtuálním stroji
bez ohledu na základní architektuře počítače.
Programovací jazyk Java má poměrně jednoduchou syntaxi,
podobnou programovacím jazykům \texttt{C} a~\texttt{C++}.
\cite{oracleJava}


% popularita, kde je používaná
Programovací jazyk Java je jedním z~nejpopulárnějších programovacích jazyků.
Byl využit pro vytvoření mnoha bankovních a~finančních systémů po celém světě.
Je také používaný velkými podniky jako je Amazon, Google nebo Facebook,
díky čemuž je považován za jedno z~nejlepších řešení pro vývoj podnikových i~webových systémů.

% bezpečnost
Java má mnoho vestavěných zabezpečovacích funkcí pro pokročilé ověřování,
kryptografii a~řízení přístupu, které jsou velmi užitečné pro vývoj webových aplikací.
Za pomocí těchto funkcí, mohou vývojáři s~výhodou využívat komplexní
rozhraní, zahrnující mechanismy pro bezpečné přihlášování, digitální podpisy
a~možnost vytvářet vlastní bepečností politiku.

% rozmanitá sada volně dostupných nástrojů a~knihoven
Spousta špičkových firem, vyvíjejících webové aplikace, dává přednost Javě
před jinými technologiemi díky rozmanité sadě volně dostupných nástrojů a~knihoven.
Java poskytuje nejrůznější rozhraní pro vytváření sítí, zpracování různorodých dat,
napojení na databáze, jejich správu a~nespočetné množství dalších věcí.
Příkladem volně dostupných open source knihoven pro další funkcionalitu může být
Apache POI, Google Guava, Jackson a~další.

% příklady
Javu používá mnoho slavných webových stránek jako jsou
eBay.com, Amazon.com, LinkedIn.com a~Facebook.com.
Je považována za jeden z~nejlepších nástrojů
pro vývoj jakékoliv podnikové webové aplikace,
v~téměř jakémkoliv průmyslovém odvětví včetně zdravotnictví,
výroby či finančnictví.

% IDE
Pro Javu lze použít nejrůznější nástroje usnadňující vývoj a~vynikající volně dostupná vývojová prostředí
jako například \texttt{NetBeans}, který jsme používali pro vývoj prvních verzí backendových modulů.
% Poznámka pod čarou
Aktuálně používáme vysoce populární vývojové prostředí \texttt{IntelliJ IDEA}
od společnosti JetBrains.

% Mult-thrading
Díky schopnosti více-vláknového zpracování
mohou Java aplikace spravovat více uživatelů či vláken najednou.
Java napomáhá vytvářet co nejvíce procesových vláken z~jediné instance
spuštěné Java aplikace na stejném počítači, podle toho jak to aplikace vyžaduje.

% Škálovatelnost

% Objektová orientace
Jednou z~hlavních příčin popularity Javy je její objektová orientace.
Pro vývoj webových aplikací tato schopnost může být velice žádoucí,
objektově orientované aplikace se jednodušeji spravují a~programují.
Objektový přístup udržuje systém modulární, flexibilní a~škálovatelný.
Objekty vytvářené v~Javě lze znovu použít v~jiných částech systému.
Možnost znovu použít jednotlivé části systému může výrazně snížit náklady na vývoj.

% Komunita
Další velkou výhodou tohoto programovacího jazyka je rozsáhlá komunita vývojářů,
díky čemuž existuje spousta různých diskuzních fórem,
skupin, seminářů atd. Členové těchto komunit
jsou ochotní napomáhat a~sdílet své znalosti mezi sebou.
Díky těmto komunitám lze získat různorodé pohledy na řešené problémy
a~jejich různé možnosti řešení.
\cite{xicom}

\sekce{Apache Maven}

Pro vývoj backendových modulů bylo třeba použít nějaký nástroj,
díky kterému budeme moci efektivně spravovat naše aplikace,
stahovat a~používat různé frameworky, knihovny, pluginy
a~definovat určité informace o~našich projektech včetně jejich vzájemných závislostí.

K~těmto účelům jsme se rozhodli používat \texttt{Maven} od firmy Apache.
Maven je nástroj pro správu a~vytváření projektů založených na Javě.
Primárním cílem nástroje Maven je umožnit vývojářům získat přehled o~stavu
vývoje v~co nejkratším čase.

% Usnadnění procesu sestavení aplikací
Maven ulehčuje proces sestavení aplikací a~snaží se poskytnout především
nejdůležitější informace týkající se tohoto procesu,
odstíněné od méně podstatných detailů,
které se však dají v~případě potřeby získat.

% Poskytnutí jednotného systému sestavení aplikací
Maven poskytuje jendotný systém pro sestavení aplikací.
Jak má být projekt sestaven je možné definovat pomocí
jeho objektového modelu projeku (project object model),
který je v~aplikaci reprezentován konfiguračním xml dokumentem
a~sadou pluginů, které jsou sdílené pro všechny projekty.
Jakmile se uživatel Mavenu seznámí s~tímto procesem sestavování aplikací,
je již díky jednotné struktuře poměrně snadné se zorientovat i~v~jiných aplikacích,
vytvořených pomocí Maven.

% Poskytnutí kvalitních informací o~projektu
Prostřednictvím dat definovaných v~objektovém modelu projektu (obyčejně pom.xml)
a~zdrojových kódů je Maven schopen podávat spoustu užitečných informací o~projektu,
např.: křížové zdoje, seznam závistlostí, reporty, týkající se testů aplikace atd.

% Poskytování pokynů a~rad pro vývoj osvědčených postupů
Maven se snaží vytyčovat určité osvědčené postupy pro vývoj
a~napomáhat tak vést vývoj projektu určitým směrem.
V~tomto ohledu je kladen důraz například na testování,
kde je specifikace a~spouštění určitých druhů testů
součástí normálního cyklu sestavení aplikace.
\cite{maven}


\sekce{Apache Tomcat}
\texttt{Tomcat} je jedním z~nejrozšířenějších
aplikačních Java serverů pro provoz webových aplikací.
Základní komponenty Apache Tomcat jsou \texttt{Catalina}, \texttt{Coyote} a~\texttt{Jasper}.

% Catalina
\texttt{Catalina} funguje v~rámci Tomcatu jako servlet kontejner.
To znamená, že implementuje specifikace pro \texttt{servlety}
\footnote{\texttt{Servlet} je Java třída zpracovávající HTTP požadavky.}
a~technologii \texttt{Java Server Pages}
\footnote{\texttt{Java Server Pages} je Java technologie pro vykreslování webového obsahu založená na HTML.} (JSP).

% Coyote
\texttt{Coyote} je konektorovou komponentou Tomcatu podporující protokol HTTP 1.1
a~funguje jako webový server, který spravuje lokální soubory a~HTTP dokumenty.
Coyote naslouchá na určitém TCP portu a~očekává příchozí připojení,
následně předává obdržené požadavky na Tomcat Engine pro jejich zpracování
a~odesílá zpět odpověd klientovi, který požadavek odeslal.

% Jasper
\texttt{Jasper} je engine pro zpracování JSP.
Soubory JSP zpracovává a~kompiluje je do Java kódu jakožto servlety,
které pak může obsluhovat Catalina.
\cite{tomcatWikipedia}

% TomEE
Poměrně důležitou nádstavbou k~Apache Tomcat je \texttt{TomEE},
který podporuje dodatečné technologie,
jako například populární \texttt{Java Persistence API} (JPA) pro práci s~databází,
které je více popsáno v~samostatně sekci.

Apache Tomcat lze použít i~jako vestavěnou aplikaci v~rámci webové aplikace.
Při vývoji webové aplikace pak lze s~využitím vestavěného tomcatu
spouštět pouze samotnou webovou aplikaci, jelikož sama sobě vyvolá
potřebné funkce serveru pro spuštění a~správný chod.
Spouštění vestavěného serveru může velice zjednodušit vývoj,
jelikož se vývojář musí vypořádat pouze s~jedinou komponentou a~to aplikací samotnou,
tím pádem nemusí vůbec řešit nasazování aplikace na aplikační server.
\cite{javaWorld}

Z~hlediska lokálního vývoje našich backendových modulů jsme dříve používali
spuštěný Tomcat jakožto nezávislého hostitele pro vyvíjené webové aplikace.
Aktuálně jsme však začali využívat možnosti spouštění technologie Tomcat jako vestavěnou
aplikaci za pomocí knihovny Spring Boot, o~které je možno se dozvědět více v~sekci
věnované frameworku Spring.

\sekce{Java Persistence API}
\texttt{Java Persistence API} (JPA) poskytuje Java vývojářům
objektově-relační mapování pro správu relačních dat v~Java aplikacích.

% ORM
Objektově-relační mapování lze zjednodušeně vysvětlit jako
programovací techniku pro přemodelování relační databáze
na objektově orientovaný model v~aplikaci.
Se samotnými záznamy databáze lze následně v~rámci aplikace pracovat jako s~objekty.

%Java Persistence se skládá ze 4 oblastí: samotného Java Persistence API,
%dotazovacího jazyka, Java Persistence Criteria API
%a~objektově/relačních mapovacích metadat.

Jednou z~nejdůležitějších částí JPA jsou entitní třídy.
Entitní třídy ve své podstatě reprezentují databázovou tabulku
relační databáze a~instance entitních tříd odopovídají jednomu řádku v~tabulce.

Trvalý stav entit je reprezentován prostřednictvím jejich atributů,
u~kterých se používají objektově-relační mapovací anotace
pro správné namapování databázových entit a~jejich vazeb.

Níže je možné si prohlédnot ukázku entitní třídy \texttt{Obec} z~backendového
modulu \texttt{oe-adresy}.
Třída byla mnou implementována na základě databázové tabulky
\texttt{obec} navržené Ing. Martinem Bendíkem.

U~entitní třídy je možné spatřit
význačné anotace z~balíčku \texttt{javax.persistence} knihovny \texttt{JPA},
pro mapování entitní třídy, například anotace \texttt{@Entity}, \texttt{@Table}
a~\texttt{@Column}.

\begin{lstlisting}
...

@Entity
@Table(name = "obec")
@EntityListeners(AuditingEntityListener.class)
public class Obec implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Basic(optional = false)
    @Column(name = "id", unique = true, nullable = false)
    private Long id;

    @Basic(optional = false)
    @Column (name = "nazov", length = 255, nullable = false)
    private String nazov;

    @Basic(optional = false)
    @Column(name = "psc", length = 5, nullable = false)
    private String psc;

    @ManyToOne
    @JoinColumn(name = "id_okresu")
    private Okres okres;

    @OneToMany(cascade = CascadeType.ALL,
    fetch = FetchType.LAZY,
    mappedBy = "obec")
    private Set adresy;

...

\end{lstlisting}

Anotace \texttt{@Entity} označuje třídu \texttt{Obec}
jako entitní třídu a~v~kombinaci s~anotací \texttt{@Table}
a~použitím parametru \texttt{name} s~hodnotou \texttt{"obec"}
je určeno, pro jakou databázovou tabulku bude entitní třída použita.
Anotace \texttt{@Column} uvedené nad některými atributy třídy
říkají knihovně JPA, které atributy náležejí jakým databázovým sloupcům a~s~jakými omezeními.
V~příkladu je možné vidět i~anotace \texttt{@ManyToOne} a~\texttt{@OneToMany},
které zachycují vazby na jiné databázové tabulky včetně jejich kardinalit.

% Dotazovací metody JPA
JPA nabízí 2 význačné metody pro vytváření databázových dotazů,
\texttt{The Java Persistence query language} (JPQL) a~\texttt{The Criteria API}.
% JPQL
\texttt{JPQL} je dotazovací jazyk velice podobný SQL, používaný pro databázové dotazování.
% Criteria API
\texttt{The Criteria API} se používá pro vytváření typově bezpečných dotazů
prostřednictvím specifických rozhraní programovacího jazyka Java.
\cite{oracleJPA}

Pro práci s~daty v~backendových aplikacích využíváme referenční implementaci
JPA \texttt{Hibernate}, která je k~dispozici prostřednictvím frameworku Spring.

\sekce{Framework Spring}

\texttt{Framework Spring} je vysoce používaným a~volně dostupným frameworkem
jazyka Java pro vývoj podknikových a~webových aplikací.
Nabízí mnoho technologických řešení, které je možné s~výhodou
použít a~tím velice zefektivnit vývoj.
Framework Spring je rozdělen do několika modulů.
Tyto moduly lze libovolně používat a~kombinovat dle potřeby.

Spring nabízí základní podporu pro různé aplikační architektury,
zahrnující zasílaní zpráv, správu transakčních dat a~web.
Pro vývoj webových aplikací jsou k~dispozici 2 dceřiné frameworky,
Spring MVC web framework založený na technologii servletů
a~paralelně Spring WebFlux reactive web framework.

% Design Philosophy
Spring framework byl vystavěn na základě určitých principů.
% Možnost výběru na různých úrovních
Jedním z~nich je poskytnutí možnosti výběru na různých úrovních vývoje.
Spring umožňuje určitá rozhodnutí týkající se návrhu systému
co nejvíce odložit, případně i~změnit.
Příkladem může být změna poskytovatelů
pro správu dat prostřednictvím konfigurace,
aniž by bylo nutné měnit kód aplikace.
Stejná flexibilita platí i~pro koncepty související s~infrastrukturou
a~integrace s~aplikačními rozhraními třetích stran.

% Podpora různých perspektiv vývoje
Framework Spring podporuje poměrně širokou škálu perspektiv vývoje
a~lze jej přizpůsobit různým potřebám aplikace.
% Zpětná kompatibilita
Spring udržuje poměrně silnou zpětnou kompatibilitu.
Z~těchto důvodů framework podoporuje pouze určitou řadu
pečlivě vybraných verzí Java Development Kit
a~knihoven třetích stran usnadňujících správu aplikací
a~knihoven závislých na frameworku Spring.

% Inuitivita a~jednoduchost použití
Vývojáři tohoto frameworku se snažili vytvořit aplikační rozhraní tak,
aby bylo velice intuitivní a~vydrželo v~mnoha verzích po mnoho let.
% Dokumentace
Proto byly nastaveny vysoké standardy pro kvalitu kódu.
Framework Spring klade velký důraz na smysluplný, aktuální a~přesný javadoc
(Java dokumentace).

% Dependency Injection and Inversion of Control
Přestože Java platforma nabízí bohatou funkcionalitu pro vývoj aplikací,
postrádá prostředky k~uspořádání základních stavebních jednotek do souvislého celku.
Tento úkol je ponechán softwarovým architektům a~vývojářům.
K~těmto účelům je možné použít návrhové vzory, jako jsou továrny, abstraktní továrny,
stavitel, dekorátor, pro skládání různých tříd a~instancí objektů,
které výseledně tvoří aplikaci.
Tyto návrhové vzory jsou formalizovanými osvědčenými postupy,
které je však nutné nějakým způsobem implementovat.

Komponenta Spring Framework \texttt{Inversion of Control} řeší tento problém
poskytováním formalizovaných prostředků pro sestavování nesourodých
součáští do plně funkční aplikace připravené k~použití.
Spring framework implementuje určité návrhové vzory a~poskytuje
je prostřednictvím objektů, které je možné integrovat do vlastních aplikací.
Mnoho organizací využívá Spring Framework tímto způsobem k~vývoji robustních
a~udržovatelných aplikací.

Framework Spring se skládá z~různých funkcionalit organizovaných do 20 různých modulů.
Tyto moduly jsou seskupeny do částí Core, Container, Data Access/Integration,
Web, Aspect Oriented Programming (AOP), Instrumentation a~Test,
jako je vyzobrazeno na obrázku 3 níže.

\cite{springFrameworkDocs}

\obrazek
\vlozobr{bakalarska-prace/spring-overview}{0.55}
\endobr{Přehled modulů Spring frameworku
\obrzdroj{Spring Framework Reference Documentation, 2010}}

Dále budou stručně představeny určité moduly frameworku Spring,
které používáme pro vývoj java aplikací backendu.

% Core a~Beans - IoC, BeanFactory
Moduly Core a~Beans poskytují základní části frameworku,
zahrnující funkce Inversion of Control a~Dependency Injection.
Jednou z~těchto funkcionalit je \texttt{BeanFactory},
což je sofistikovaná implementace návrhového vzoru továrna.
BeanFactory odstraňuje potřebu používat programové jedináčky
a~umožňuje oddělit konfiguraci a~specifikaci závislostí aplikace od skutečné logiky programu.


Ze Skupiny Data Access/Integration modulů používáme především \texttt{JDBC}, \texttt{ORM}
a~modul \texttt{Transaction}.

% JDBC
\texttt{JDBC} modul poskytuje vrstvu pro Java Database Connection
-- JDBC, aplikační rozhraní pro připojení do databází,
která odstraňuje potřebu zdlouhavého implementování JDBC
a~zpracování chybových stavů specifických pro různé druhy databázových systému.

% ORM
Modul \texttt{ORM} poskytuje integrační vrstvy pro populární objektově-relační mapování
zahrnující JPA, Hibernate a~další technologie.
Tyto 2 technologie lze použít v~kombinaci s~dalšími funkcemi, které Spring nabízí,
jako například funkce pro deklarativní správu databázových transakcí.

% Transaction
Modul \texttt{Transacion} podporuje programové a~deklarativní řízení
transakcí pro třídy, které implementují speciální rozhraní
a~pro všechny obyčejné Java objekty (POJOs).
% Web, MVC
Další moduly, které používáme jsou Web a~Servlet, patřící do rodiny modulů Web.
Kombinace těchto 2 modulů poskytuje implementaci architektury MVC
pro webové aplikace.
\cite{springFrameworkDocs}

% Spring Boot
Jedním z~nejčastěji používaných Spring projektů,
je projekt \texttt{Spring Boot}, který jsme se rozhodli v~backendových modulech použít.
Spring Boot usnadňuje vytváření samostatných spustitelných aplikací
založených na frameworku Spring.
\cite{springbootDocs}

\sekce{Swagger, OpenAPI specifikace}

Pro efektivní propojení backendu a frontendu bylo nutné používat určitou specifikaci,
která zjednoduší, zdokumentuje a zpřehlední dostupné backendové služby.
K těmto účelům byla použita \texttt{OpenAPI} specifikace, dříve známá jako \texttt{Swagger} specifikace.
Jedná se o světový standard pro definování RESTových aplikační rozhraní.
OpenAPI specifikace popisuje dostupné \texttt{REST} služby, včetně adresy serveru,
koncových bodů služeb, zabezpečení, posílaných dat a spoustu dalších informací.
\par
Při vývoji využíváme Swagger specifikace ve verzi 2.0, které definujeme prostřednictvím
webového editoru
\footnote{Swagger Editor je volně dostupný z adresy: \texttt{https://editor.swagger.io/}},
v programovacím jazyce \texttt{Yaml}.
Tyto vydefinované specifikace zapojujeme do aplikací backendu i frontendu.
Swagger od společnosti SmartBear poskytuje i dodatečné technologie,
díky kterým lze z vydefinovaného rozhraní generovat kód v různých programovacích jazycích.
Případně je možné proces provádět i opačně, tím pádem lze z určitého kódu
rozhraní služeb backendových aplikací generovat OpenAPI specifikace.
V našem případě pro implementaci backendových modulů definujeme Swagger specifikace,
ze kterých po zapojení do těchto modulů generujeme kód rozhraní pro vrstvu controller
(architektura MVC) v programovacím jazyce Java.
\par
Použitím Swagger technologií u obou částí webové aplikace (frontendu i backendu)
získáváme poměrně důslendou kontrolu nad celým procesem komunikace mezi těmito částmi.

\sekce{JSON Web Token}
\texttt{JSON Web Token} je otevřený standard pro zabezpečný přenos dat
mezi různými stranami webu ve formátu \texttt{JSON} (JavaScriptové objektové notace).
Posílané informace mohou být ověřeny a považovány za důvěryhodné
díky tomu, že jsou digitálně podepsány. Tokeny mohou být podepsány
pomocí tajného klíče (s využitím šifrovacího alogritmu \texttt{HMAC}) nebo
s využitím páru soukromého a veřejného klíče s použítím algoritmů \texttt{RSA} či \texttt{ECDSA}.
\cite{jwt}
\par
\texttt{JWT} používáme pro zabezpečení backendových služeb.
Jedná se o služby registrace, přihlašování a služby, které na požádání poskytují
data, které se týkají konkrétního příhlášeného uživatele.


\kapitola{Vlastní práce -- vývoj backendových modulů}

Do vývojového týmu gamifikovaného informačního systému jsem se začlenil v květnu 2018,
v době kdy byl projekt téměř na svém začátku a započaly se vytyčovat hlavní cíle a základy systému.
Od této doby bylo realizováno mnoho schůzek, ze kterých bylo sesbíráno mnoho informací,
které byly použity pro vytvoření návrhů prvního prototypu webové aplikace gamifikovaného informačního systému.
Tento první prototyp byl implementován ve druhé polovině roku 2018 a byl tak vytvořen poměrně solidní základ
pro další rozvoj webové aplikace informačního systému.

% Metodika vývoje
Od počátku vývoje se vývojový tým rozrostl o několik nových členů.
Mnoho částí systému bylo změněno nebo upraveno a byly zavedeny ucelenější postupy
a metodiky pro realizaci vývoje.
Aktuálně se pracuje na druhé verzi webové aplikace.
Vývoj probíhá prostřednictvím
zjednodušené agilní metodiky \texttt{SCRUM}, kdy jsou plánovány analytické, designové, vývojové a jiné
úkoly na každý týden. Rozplánované úkoly jsou dvakrát týdně procházeny na pravidelných schůzkách
realizovaných prostřednictvím konferenčních hovorů, kdy každý přítomný člen podává informace
o tom, na čem aktuálně pracuje, s jakými problémy se potýká a jaké úkoly dokončil během týdenního vývojového cyklu.
Na druhou stranu je z hlediska implementace programových částí kladen vysoký důraz na kvalitu práce
a každá změna, která má být do webové aplikace nasazena musí být nejdříve zkontrolována a schválena dalšími
členy vývojového týmu, kteří dané problematice rozumí.

Pro přehlednost bylo ze všech mnou implementovaných webových
REST služeb backendových modulů vybráno 5 následujících:

\begin{itemize}
\item \textbf{Služba pro registraci nového hráče}
\item \textbf{Služba pro potvrzení prvního přihlášení}
\item \textbf{Služba pro inicializaci dovednosního stromu hráče}
\item \textbf{Služba pro inicializaci úkolů nového hráče}
\item \textbf{Služba pro získaní důležitých událostí přihlášeného hráče}
\end{itemize}

V těchto službách jsou využity technologie představené v kapitole literárního přehledu.
V jednotlivých částech je popsán postup implementace jednotlivých služeb s možností použití jednotlivých technologií.

První 4 uvedené služby byly implementovány na základě servisně orientovaných modelů navržených Ing. Martinem Bendíkem.
Tyto 4 služby byly vytvořeny v~rámci backendových modulů prvního prototypu webové aplikace
a~všechny se věcně týkají vytvoření a inicializace nového uživatele.

Pro poslednní službu jsem na základě požadavků a~dostupného databázového modelu,
po vzoru jiných služeb, navrhnul taktéž servisně orientovaných model,
jehož prototyp jsem následně implementoval.
Poslední služba bude využita v~rámci nové verze systému.

\clearpage

\sekce{Služba pro registraci nového hráče}

Služba byla implementována v~rámci modulu \texttt{oe-security} pro potřebu vytvoření nového uživatelského účtu.
Novému uživateli systému je tedy za pomocí této služby připraven účet,
díky kterému se bude moci do webové aplikace přihlašovat a~bude mu tak umožněno používat její základní funkcionalitu.
Modul oe-security je modul, který spravuje veškeré operace týkající se zabezpečení aplikace.
To znamená, že poskytuje služby pro přihlášení, odhlášení a~operace pro zabezpečení služeb jiných modulů.

Služby poskytované uživatelům jsou zabezpečeny prostřednictvím \texttt{JWT} (JSON Web Token).
Uživatel po úspěšném přihlášení do systému obdrží z~modulu oe-security zašifrovaný token.
Obdržený token je následně uložen do lokálního uložiště klientova webového prohlížeče.
Tímto je uživatel autentizován a~další služby jsou z~aplikace volány s~tímto tokenem vloženým do hlavičky HTTP požadavku.
Takto jsou příchozí požadavky vyhondnoceny, zda obsahují v~hlavičče validní token a~pokud ano,
tak je toto volání považováno za autentizované a~validní.
Z~příchozího tokenu je možné získnat id přihlášeného uživatele,
které je použito pro získaní dat, týkajících se tohoto uživatele.

Nový uživatel je do systému registrován po obdržení a~potvzení emailu s~pozvánkou.
Pozvánku budou mít možnost zasílat všichni uživatelé systému.
Po potvrzení pozvánky je uživatel přesměrován na registrační
formulář, kde vyplní svůj email, login a~heslo.
Na základě odeslání tohoto formuláře je mu vytvořen a~inicializován účet.
Tuto HTTP POST operaci obsluhuje služba pro registraci nového hráče.

\vspace{10}

\noindent{Vstupem této služby je objekt s~názvem \texttt{NovyHracDto} a~jeho atributy jsou:}
\begin{itemize}
\item email -- email, na který byl zaslán email s~pozvánkou,
\item login -- název účtu, volený pseudonym,
\item heslo,
\item registrationToken -- registrační token, získaný z~emailové pozvánky,
\item idParent -- ID nadřízeného.
\end{itemize}

Po úspěšném zpracování požadavku je vrácen výstupní objekt,
který byl nazván \texttt{LoginResponseDto}.
Jedná se o~jednoduchý objekt zapouzdřující atribut \texttt{accessToken}, znakový řetězec reprezentující přístupový token.

Na základě servisně orientovaného modelu navrženého Ing. Martinem Bendíkem
byla vydefinována HTTP POST operace ve Swagger REST API specifikaci pro modul oe-security.
Úryvek z této specifikace, který popisuje registrační službu je k nahlédnutí v kapitole příloh.

Služba pro registraci provádí databázovou transakci,
která zastřešuje 5 databázových operací.
Pro zpřístupnění základní funkcionality webové aplikace nově registrovanému uživateli je nutné vytvořit 5 nových záznamů
v~5 vzájemně provázaných databázových tabulkách.
Jedná se o~tabulky \texttt{osobne\_udaje},
\texttt{udaje\_postavy}, \texttt{nastavenia}, \texttt{hrac} a~\texttt{prihlasovacie\_udaje}.

Pro práci s~uvedenými databázovými tabulkami byly v~jazyce Java implementovány příslušné entitní třídy.
Enitní třídy reprezentují databázové tabulky prostřednictvím
objektově-relačního mapování (\texttt{ORM}).
Diagram enitních tříd, se kterými služba pro registraci pracuje, je vyobrazen níže.

\obrazek
\vlozobr{bakalarska-prace/oe-security-domain-simple.png}{0.6}
\endobr{Zjednodušený class diagram entitních tříd modulu oe-security
\obrzdroj{Vygenerováno pomocí vývojové prostředí IntelliJ IDEA}}

\clearpage

Pro uložení nových záznamů do databáze bylo implementováno několik obslužných metod ve třídě \texttt{LoginServiceImplementation}.
Každá metoda připravuje nový entitní objekt pro uložení do určité databázové tabulky.

Stěžejní public metodou, která je důležitá pro realizaci celé databázové transakce, je metoda \texttt{createNewHrac}.
Do této metody vstupuje objekt \texttt{NovyHracDto}, který byl získán na základě přijatého těla HTTP požadavku.
Metoda vytváří nový objekt od entitní třídy \texttt{PrihlasovacieUdaje} a~nastaví mu hodnoty dle vstupního objektu \texttt{novyHracDto}, včetně hesla zašifrovaného pomocí šifrovacího alogritmu \texttt{SHA256}.

Metoda \texttt{createNewHrace} provolává private metodu \texttt{initHrac}.
Metoda \texttt{initHrac} vytváří a incializuje objekt entitní třídy \texttt{Hrac}
i společně s jeho navázanými 3 entitními objekty
 \texttt{osobniUdaje},
\texttt{udajePostavy}, \texttt{nastaveni}.
Po inicilizaci jsou tyto 4 vzájemně provázané objekty kaskádově uložěny prostřednictvím
repozitáře databázových operací \texttt{hracRepository} a jeho metody \texttt{save}
\footnote{Metoda \texttt{save} je implementována refereční implementací JPA Hibernate.}.

Inicializovaný objekt \texttt{hrac} je využit opět v~metodě \texttt{createNewHrac},
kde je posléze pomocí jeho \texttt{id} provozán s~objektem \texttt{prihlasovacie\_udaje}.
Objekt \texttt{prihlasovacie\_udaje} je následně doplněn o~další dvě hodnoty atributů, prvního přihlášení a~uživatelské role.
Pak je již předán metodě \texttt{save}, která je poslední operací databázové transakce.

Aby bylo dosaženo provedení jednotlivých databázových dotazů uvnitř jedné transakce,
musí být metoda, případně třída anotována anotací \texttt{@Transactional}
frameworku Spring. Zdrojový kód popsané fukncionality této třídy je níže k nahlédnutí.


\clearpage

\begin{lstlisting}

@Service
@Transactional
public class LoginServiceImplementation implements LoginService {

    @Autowired
    private HracRepository hracRepository;

    @Autowired
    private PrihlasovacieUdajeRepository prihlasovacieUdajeRepository;

    ...

@Override
public PrihlasovacieUdaje createNewHrac(NovyHracDto novyHracDto) {

        // pokud jiz existuje hrac s takovymi prihl. udaji, vyhodit vyjimku
        if (prihlasovacieUdajeRepository
                        .existsByLoginOrEmail(
                            novyHracDto.getLogin(),
                            novyHracDto.getEmail())) {
            throw new ErrorCodeException(
                            ErrorCodeEnum.NEPLATNA_REGISTRACE,
                            "Uzivatel s temito prihasovacimi udaji jiz existuje.");
        }

        PrihlasovacieUdaje prihlasovacieUdaje = new PrihlasovacieUdaje();
        prihlasovacieUdaje.setLogin(novyHracDto.getLogin());
        prihlasovacieUdaje.setEmail(novyHracDto.getEmail());

        // nastavit zahashovane heslo dle algoritmu SHA256
        prihlasovacieUdaje.setPassword(Hashing.sha256().hashString(
                novyHracDto.getHeslo(), StandardCharsets.UTF_8).toString());

        // provolat inicializaci Hrace a~provazat s~jeho ID
        prihlasovacieUdaje.setIdHraca(initHrac(novyHracDto).getId());

        // uzivatel se prihlasuje poprve
        prihlasovacieUdaje.setPrvePrihlasenie(true);
        prihlasovacieUdaje.setIdRola(ID_ROLE_STANDARD);
        return prihlasovacieUdajeRepository.save(prihlasovacieUdaje);
    }

...

    private Hrac initHrac(NovyHracDto novyHracDto) {
        Hrac hrac = new Hrac();
        hrac.setOsobneUdaje(initOsobniUdaje());
        hrac.setUdajePostavy(initUdajePostavy());
        hrac.setNastavenia(initNastaveni());
        // set ID nadrizeneho
        hrac.setIdParent(novyHracDto.getIdParent());
        return hracRepository.save(hrac);
    }
\end{lstlisting}

\vspace{10}

HTTP REST operaci pro registraci uživatele obsluhuje třída \texttt{LoginRestController},
kterou je možno vidět v přílohách.
Tato třída zpracovává přijaté HTTP požadavky a~jejich těla ve formátu JSON.
Na základě zpracování požadavků provolává potřebné metody pro zpracování dat
a~odesílá zpět příslušnou HTTP odpověď dle standardu REST.

Aby byla třída aplikací registrována, jakožto třída zpracovávající REST operace,
byla anotována anotací \texttt{@RestController} frameworku Spring.
Další význačnou anotací tohoto frameworku, kterou byla třída opatřena, je \texttt{@RequestMapping}.
Díky této anotaci je specifikováno pod jakou URL adresou tato třída zpracovává požadavky,
v~jakém formátu požadavky příjmá a~v~jakém formátu odesílá odpovědi.

HTTP POST operaci registrace nového uživatele zpracovává metoda \texttt{postNovyHrac},
fungující pod URL koncovým bodem \texttt{/rest/security/registration}.
Metoda \texttt{postNovyHrac} volá metodu \texttt{createNewHrac} přes instanci rozhraní \texttt{loginService}.
Z~návraceného objektu z~metody \texttt{createNewHrac} je vytvořen token,
který je uložen do atributu \texttt{accessToken} odchozího objektu \texttt{LoginResponseDto}.
Objekt \texttt{LoginResponseDto} je následně odeslán ve formátu JSON ven z~aplikace.

\clearpage

\sekce{Služba pro potvrzení prvního přihlášení}

Pro zobrazení určitých vizuálních prvků a~informací uživateli, je třeba rozlišovat,
zda se uživatel do systému přihlašuje poprvé. Jedním ze zobrazovaných prvků uživateli po prvním přihlášení je například uvítací modální okno,
které hráče přivitá do aplikace a~ve stručnosti ho s~naší aplikací seznámí.
Jakmile je uživatel proveden celým uvítacím procesem, nechceme ho již při dalším přihlášení do systému
obtěžovat těmito informacemi a~proto mu již určité prvky nebudou znovu zobrazeny.

Informace o~prvním přihlášení určitého uživatele je uchována v~databázové tabulce \texttt{prihlasovacie\_udaje}.
Do aplikace je zasílána službou modulu \texttt{oe-hrac} společně s~dalšími údaji o~uživateli ihned po uživatelově přihlášení.

Po zobrazení prvků spojených s~prvním vstupem do aplikace je nutné odeslat požadavek na změnu příznaku prvního přihlášení.
Proto bylo potřebné vytvořit službu, díky které bude možné tento příznak změnit.
Jelikož se jedná o~službu týkající se základního panelu hráče, byla tato služba implementována v~modulu \texttt{oe-hrac}.

Služba pro potvrzení prvního přihlášení je implementačně poměrně jednoduchá.
Pracuje pouze s~jednou již výše uvedenou databázovou tabulkou \texttt{prihlasovacie\_udaje},
kde na základě přijatého požadavku mění v~příslušném řádku tabulky hodnotu prvního přihlášení,
definovanou logickým datovým typem \texttt{boolean}.

Po registraci je hodnota prnvího přihlášení uživateli nastavena na \texttt{true}.
Uživatel se úspěšně přihlásí a obdrží autorizační token pro volání dalších služeb.
Provede se uvítací proces v aplikaci a po ukončení tohoto uvítání
je volána služba pro potvrzení prvního přihlášení.

HTTP PUT požadavek této služby je volán s objektem \texttt{PrvniPrihlaseniDto},
který obsahuje hodnotu prvního přihlášení nastavenou na \texttt{false}, v těle
a s hlavičkou obsahující autorizační JWT token.

Tento požadavek je přijat controllerem, který je implementován třídou \texttt{HracRestController}.
\texttt{HracRestController} po přijetí požadavku konroluje validnost tokenu, ze kterého získá id hráče
a společně s přijatým objektem \texttt{PrvniPrihlaseniDto} volá metodu \texttt{editPrvniPrihlaseni}
třídy \texttt{HracServiceImplementation}
\footnote{Třída \texttt{HraceServiceImplementation} implementuje podnikovou logiku služby.}.

Pro editaci hodnoty prvního přihlášení v databázi je v metodě \texttt{editPrvniPrihlaseni} nejdříve dohledána
instance přihlašovacích údajů dle id hráče přihlášeného uživatele.
Instance přihlašovacích údajů je reprezentována objektem \texttt{prihlasovacie\_udaje},
kterému je nastavena hodnota atributu \texttt{prvniPrihlaseni} na \texttt{false},
dle hodnoty nastavené v příchozím objektu \texttt{prvniPrihlaseniDto}.
Záznam je po úpravě uložen do databáze pomocí metody \texttt{save}
\footnote{Metoda \texttt{save} je v tomto případě použita pro provedení aktualizace záznamu v databázi}.

Služba je poskytována pod URL koncovým bodem \texttt{/rest/hrac/prvni-prihlaseni} a~HTTP metodou PUT.
Příslušná PUT operace je registrována pod metodou \texttt{putPrvniPrihlaseni} třídy \texttt{HracRestController}.

Popisovanou fuknkcionalitu třídy \texttt{HracServiceImplementation} společně s ukázkou třídy \texttt{HracRestController}
si může čtenář prohlédnout v~kapitole příloh.

\clearpage

\sekce{Služba pro inicializaci dovednosního stromu hráče}

Každý uživatel systému získává za plnění pracovních úkolů určité dovedností body.
Tyto dovedností body náleží dovednostem, které v~průběhu kariéry ve firmě Optimal Energy za používání našeho systému,
uživatel získává a~rozvíjí.
Díky těmto rozvíjeným dovednostem uživatel vidí,
jak se v~různých činnostech zlepšuje a~nabývá nových zkušeností či vědomostí.

V~systému jsou dovednosti rozděleny do určitých kategorií dle věcného významu.
Podle vydefinovaných pravidel v~databázy jsou pak přidělovány
zmíněné body k~určitým dovednostem za splnění pracovních úkolů evidovaných naším systémem.

Pro správu dovedností hráčů byl zřízen samostaný modul \texttt{oe-dovednosti},
který pracuje s~daty těchto dovedností.
Před tím než uživatel začne plnit v~systému pracovní úkoly je nezbytné,
aby mu byla připravena příslušná struktura dat, týkající se jeho dovedností,
které při plnění úkolů bude rozvíjet.
Proto byla vyvinuta služba pro inicializaci dovednostního stromu hráče.

Pro vytvoření struktury dat dovedností (jinak dovednostního stromu) určitého uživatele je nutné:

\begin{itemize}

\item vytvořit v~databázové tabulce \texttt{kategoria\_dovednosti} instanci od každého druhu dovednostní kategorie
\item  a~následně vytvořit nové záznamy v~tabulce \texttt{dovednost} od každého typu dovednosti.
\end{itemize}

Data jednotlivých druhů kategorií dovedností a~druhů dovedností jsou
uloženy v~tabulkách \texttt{typ\_kategoria\_dovednosti} a~\texttt{typ\_dovednosti}.
Entitní třídy, zrcadlící databázové tabulky prostřednivtím ORM, se kterými služba pracuje,
jsou \texttt{TypKategoriaDovednosti}, \texttt{TypDovednosti}, \texttt{KategoriaDovednosti} a~\texttt{Dovednost}.
Na uvedeném obrázku 2 níže je možné si prohlédnout zjednodušený class diagram modulu \texttt{oe-dovednosti}.

\clearpage

\obrazek
\vlozobr{bakalarska-prace/oe-dovednosti-domain-simple.png}{0.5}
\endobr{Zjednodušený class diagram entitních tříd modulu \texttt{oe-dovednosti}
\obrzdroj{Vygenerováno pomocí vývojové prostředí IntelliJ IDEA}}

Pro správné vytvoření celého dovednostního stromu hráče bylo ve třídě KategorieDovednostiServiceImplementation vytvořeno 6 metod,
příčemž 5 z~nich jsou pomocné private metody.

Nejdříve byly implementovány metody pro vygenerování kategorií dovedností přihlášeného hráče.
Metoda nesoucí název \texttt{createKategorieDovednosti} obstarává vložení nového záznamu kategorie dovednosti dle zadaného id hráče a~objektu třídy
\texttt{TypKategorieDovednosti}.
V~metodě \texttt{initKategorieDovednosti} je z~databáze získán seznam všech typů dovedností
a~pro každou položku z~tohoto seznamu je provolána metoda \texttt{createKategorieDovednosti} pro vytvoření nové kategorie dovednosti určitého uživatele.
Díky těmto dvěma metodám jsou vygenerovány všechny potřebné kategorie dovedností danému uživateli.

Jakmile jsou vytvořeny dovednostní kategorie započnou se vytvářet všechny potřebné dovednosti.
K~tomuto jsou použity metody \texttt{initDovednostiHrace}, \texttt{createAllDovednostiKategorie} a~\texttt{createDovednost}.
Metoda \texttt{initDovenostiHrace} projde vstupní seznam kategorií dovedností
a~pro každou položku provolá metodu \texttt{createAllDovednostiKategorie}.
Metoda \texttt{createAllDovednostiKategorie}  podle typu kategorie dovednosti,
získaného ze vstupního objektu kategorie dovednosti,
dotáhne z~databáze příslušné typy dovedností a~pro každou položku z~tohoto seznamu provolá metoda \texttt{createDovednost},
která zapříčiní vytvoření nové dovednosti.

Vygenerování celého dovednostního stromu hráče je spuštěno zastřešující public metodou \texttt{initStromDovednosti},
která provolává 2 výše popsané metody \texttt{initKategorieDovednostiHrace} a~\texttt{initDovednostiHrace}.
Aby byla zajištěna konzistence dat, je popsaná funkcionalita těchto 6 metod realizována jako databázová transakce.

Služba je poskytována prostřednictvím třídy \texttt{DovednostiRestController} jakožto HTTP POST operace \texttt{initDovednostiHrace},
pod url koncovým bodem \texttt{/rest/dovednosti/inicializace}.

\begin{lstlisting}
@Service
public class KategorieDovednostiServiceImplementation
                    implements KategorieDovednostiService {

    @Autowired
    private KategorieDovednostiRepository kategoriaDovednostiRepository;
    @Autowired
    private TypKategorieDovednostiRepository
                                typKategorieDovednostiRepository;
    @Autowired
    private TypDovednostiRepository typDovednostiRepository;
    @Autowired
    private DovednostRepository dovednostRepository;

    ...

    @Override
    @Transactional
    public void initStromDovednosti(Long hracId) {

        Iterable kategorieDovednostiIterable
                = initKategorieDovednostiHrace(hracId);

        initDovednostiHrace(kategorieDovednostiIterable);

    }

    private List initKategorieDovednostiHrace(Long hracId) {

        // ziskat seznam vsech typu kategorii dovednosti
        Iterable typyKategorieDovednosti
                = typKategorieDovednostiRepository.findAll();

        List kategoriaDovednostiList
                = new ArrayList<>();

        // pro kazdy typ kategorie dovednosti
        // vytvorit hraci instanci kategorie dovednosti
        typyKategorieDovednosti.forEach(TypKategorieDovednosti -> {
                    KategoriaDovednosti kategoriaDovednosti =
                            createKategorieDovednosti(hracId, TypKategorieDovednosti);
                    kategoriaDovednostiList.add(kategoriaDovednosti);
        });

        return kategoriaDovednostiList;
    }

    private KategoriaDovednosti createKategorieDovednosti(
            Long hracId, TypKategorieDovednosti typKategorieDovednosti) {

        KategoriaDovednosti kategoriaDovednosti = new KategoriaDovednosti();
        kategoriaDovednosti.setTypKategorieDovednosti(typKategorieDovednosti);
        kategoriaDovednosti.setIdHraca(hracId);
        kategoriaDovednosti.setZiskaneSkusenosti(0);
        kategoriaDovednosti.setUroven(0);
        kategoriaDovednosti.setAktivita(0);
        return kategoriaDovednostiRepository.save(kategoriaDovednosti);
    }

    private void initDovednostiHrace(Iterable kategorieDovednostiIterable) {
        kategorieDovednostiIterable.forEach(
                KategoriaDovednosti -> createAllDovednostiKategorie(
                        KategoriaDovednosti));
    }

    private void createAllDovednostiKategorie(
            KategoriaDovednosti kategorieDovednosti) {

        // vyhledat typy dovednosti dle typu kategorie dovednosti
        Iterable typyDovednostiIterable = typDovednostiRepository
                .findByTypKategorieDovednosti(
                        kategorieDovednosti.getTypKategorieDovednosti());

        // vytvorit instanci dovednosti od kazdeho typu dovednosti
        // prislusne kategorie dovednosti
        typyDovednostiIterable.forEach(
                TypDovednosti -> createDovednost(
                        kategorieDovednosti, TypDovednosti));
    }

    private Dovednost createDovednost(
            KategoriaDovednosti kategoriaDovednosti,
            TypDovednosti typDovednosti) {

        Dovednost dovednost = new Dovednost();
        dovednost.setKategoriaDovednosti(kategoriaDovednosti);
        dovednost.setTypDovednosti(typDovednosti);
        dovednost.setUroven(0);
        dovednost.setSkusenosti(0);
        dovednost.setAktivita(0);
        return dovednostRepository.save(dovednost);
    }


\end{lstlisting}

\clearpage

\sekce{Služba pro inicializaci úkolů nového hráče}

Každý uživatel systému může za pomocí naší aplikace plnit různé pracovní úkoly.
Úkoly byly navrženy a~vytovřeny především pro nové členy firmy Optimal Energy.
Byly vytvořeny dle letitých zkušeností jiných pracovníků
a~měly by být pro nováčky vysoce přínosným interaktivním průvodcem a~pomocníkem.

Za každý splněný úkol získává užívatel určité zkušenostní body,
virtuální měnu a~v~předchozí sekci zmíněné dovednostní body.

Úkol může uživatel prostřednictvím webové aplikace spustit a~zahájit tak jeho plnění.
Po spuštění úkolu je startována časomíra, která měří dobu,
která proběhla od zahájení plnění tohoto úkolu, až do jeho ukončení.
Určité úkoly může uživatel označit sám jako splěné
a~jiné jsou plněny na základě příchozích dat z~jiného systému NIS firmy Optimal Energy.

Jednotlivé úkoly jsou uceleny do tzv. herních misí, které na sebe navazují.
Dle vydefinovaných pravidel návazností v~databázi jsou úkoly webovou aplikací nabízeny
a~uživatelem plněny v~určitém pořadí.

Různorodou funkcionalitu pro práci s~herními úkoly nabízí modul \texttt{oe-questy}.
Po registraci nového hráče do systému je potřebné mu vytvořit instanci prvního úkolu.
Na základě splění tohoto úkolu budou postupně odemykány i~další.
Proto bylo v~modulu \texttt{oe-questy} nezbytné vytvořit službu pro vytvoření instance prvního úkolu,
pro nově přihlášeného uživatele.

Implementačně se jedná o~poměrně jednoduchou databázovou transakci,
která nejdříve dohledá v~databázi instanci typu prvního úkolu dle určitého kódu a~vytvoří v~tabulce \texttt{quest}
nový záznam propojený s~dohledaným typem úkolu a~s~parametrem id hráče,
rozšifrovaného z~JWT tokenu, náležejícímu určitému uživateli.


Entitními třídami, vytvořených dle databáze pro herní úkoly,
potřebných pro fungování služby jsou \texttt{TypQuestu} a~\texttt{Quest}.


\obrazek
\vlozobr{bakalarska-prace/oe-questy-domain.png}{0.5}
\endobr{Zjednodušený class diagram entitních tříd modulu \texttt{oe-questy}
\obrzdroj{Vygenerováno pomocí vývojové prostředí IntelliJ IDEA}}


Java třída implemetnující službu nese název \texttt{QuestServiceImplementation}.
V~metodě \texttt{createQuestForNewPlayer} používá 2 instance repozitářů databázových dotazů
\texttt{QuestRepository} a~\texttt{TypQuestuRepository}, pro správné vytvoření prvního úkolu.
Pro získání instance typu prvního úkolu dle kódu je použit způsob, kdy je z~názvu metody \texttt{findByKod},
za pomocí referenční implementace Hibernate, vyvozen databázový dotaz pro získání chtěného záznamu.
Posléze je provolána obslušná private metoda \texttt{createQuest} s~parametry id hráče, typem prvního úkolu a~id připraveného stavu úkolu.
V~této private metodě je použit druhý repozitář databázových dotazů pro úkoly,
na kterém je zavolána metoda \texttt{create} se sestaveným objektem prvního úkolu nového hráče v~parametru.

Jelikož je vkládání nového záznamu prvního úkolu závislé na správném provedení databázového dotazu pro získání typu prvního úkolu,
byla metoda\texttt{ createQuestForNewPlayer} opatřena anotací \texttt{@Trasnactional} pro vytvoření databázové transakce.

\begin{lstlisting}
@Service
public class QuestServiceImplementation implements QuestService{

    @Autowired
    private QuestRepository questRepository;

    @Autowired
    private TypQuestuRepository typQuestuRepository;

    ...

    @Override
    @Transactional
    public Quest createQuestForNewPlayer(Long hracId) {

        // ziskat typ prvniho questu
        Optional typPrvnihoQuestu
                = typQuestuRepository
                    .findByKod(KOD_TYPU_PRVNIHO_QUESTU);

        // pokud nenalezen, vrat null
        if (!typPrvnihoQuestu.isPresent()) {
            return null;
        }

        // vytvorit prvni quest noveho hrace
        return createQuest(hracId, typPrvnihoQuestu.get(),
                STAV_QUESTU_PRIPRAVENY);
    }

    private Quest createQuest(Long hracId,
                              TypQuestu typQuestu,
                              Long stavQuestuId) {

        Quest quest = new Quest();
        quest.setTypQuestu(typQuestu);
        quest.setIdHraca(hracId);
        quest.setIdStavQuestu(stavQuestuId);
        quest.setDatumVzniku(new Date());
        return questRepository.save(quest);
    }

    ...

\end{lstlisting}

\clearpage

\sekce{Služba pro získaní důležitých událostí přihlášeného hráče}

Služba je implementována pro potřeby nové verze systému, v~novém prototypu modulu Timeline.
Modul Timeline bude poskytovat služby pro obsluhu dříve vzniklých událostí uživatelů.
Pro tuto verzi systému je prozatím požadována pouze služba pro získání informací o~dříve
proběhlých událostech, týkajících se uživatelova rozvoje.
Do budoucna se počítá s~tím, že by mohl tento modul nabízet služby zaměřené na vyhodnocování těchto událostí.
Mohlo by se jednat o~poskytování určitých analýz či statiských přehledů,
které by mohly mít přidanou hodnout nejen pro uživatele samotné, ale i~jejich manažery.

Služba pro získaní událostí přihlášeného hráče by měla poskytnout
uživateli jakýsi retrospektivní přehled o~tom,
co se mu v~rámci jeho kariéry, za používání našeho systému, podařilo vykonat.
Uživatel tak získá chronologický seznam splněných herních misí, úkolů,
dosažených dovedností, získáných úrovní atd.
Uvidí čeho se mu podařilo dosáhnout a~co všechno se mu již podařilo vykonat.


Pro službu na získání důležitých událostí přihlášeného hráče
bylo možno s~výhodou využít databáze pro notifikace -- notifications-db,
kam se ukládají veškeré události a~důležitá oznámení, které chceme zobrazovat uživateli.
Pro databázové tabulky, které jsou zásadní pro fungování služby, byly navrženy a~v~javě implementovány tzv. entitní třídy.
Jsou to třídy Notification, NotificationType a~TitleAttribute.
Class diagram těchto tříd je uveden níže k~nahlédnutí.


\clearpage

\obrazek
\vlozobr{bakalarska-prace/timeline-domain.png}{0.6}
\endobr{Zjednodušený class diagram entitních tříd modulu \texttt{timeline}
\obrzdroj{Vygenerováno pomocí vývojové prostředí IntelliJ IDEA}}

Pro potřeby služby je třeba vyfiltrovat pouze chtěné události na základě analýzy.
Bylo zjištěno, že je potřeba získat množinu dat bez různých aplikačních oznámení, upozornění atd.
Každá událost má jednoznačně určen svůj typ.
Typ události je uřčen uknikátním kódem (znakový řetězec).
Těchto předpokladů bylo možno využít pro oddělení dat, které bylo možno označit za nežádoucí.
Nad očištěnou množinou dat je uživateli umožněno dále vyhledávat pomocí query parametru eventTypeCodes.
\texttt{EventTypeCodes} reprezentuje pole kódů typů událostí, dle kterých může uživatel v~datech vyhledávat.
% TODO: Dle doporučení JK doplnit Vennův diagram pro lepší představu množin
Výsledná množina dat pak bude sjednocením všech událostí,
které budou odpovídat všem typům událostí dle validních kódů zadaných v~eventTypeCodes.
Pakliže nebude zadán žádný kód, budou vráceny všechny události bez uplatnění tohoto filtru.
Je předpokládáno, že vizuálně budou pro uživatele kódy reprezentovány pomocí ikon,
představující jednotlivé typy událostí.
Vzhledem k~tomu, že se do budoucna počítá s~velkým počtem různých událostí,
které v~průběhu používání aplikace uživatelem nastanou,
bylo nutné zavést i~stránkování výstupních dat.

Vstupem služby jsou JWT token přihlášeného uživatele, posílaný v~hlavičce HTTP požadavku,
ze kterého je získáno id hráče, query parametry pro stránkování offset, limit
a~dále již zmíněný query parametr pro filtorvání eventTypeCodes.

Výstupem služby je seznam EventDto objektů.
Atributy těchto objektů jsou:
\begin{itemize}
\item created -- informace o~tom, kdy byla vytvořena příslušná událost,
\item title -- titulek události,
\item eventTypeCode -- kód označující typ událostí (bude provázáno s~ikonami),
\item idRoute -- pro případné přesměrování či dotažení doplňujících údajů.
\end{itemize}


Služba je navržena a~zdokumentována servisně orientovaným modelem, kde jsou zakresleny výše zmíněné vstupy a~výstupy,
aplikační rozhraní s~url koncovým bodem  ...api/timeline/events, pod kterým bude služba dostupná,
a~třída TimelineRestController spravující přísušnou HTTP operaci.

\clearpage

\obrazek
\vlozobr{bakalarska-prace/get-player-events.png}{0.58}
\endobr{Servisně orientovaný model služby Get Player Events}

\clearpage

Na základě tohoto modelu bylo objektovou notací JSON vydefinováno Swagger API,
které slouží jako další dokumentace modulu a~jeho poskytovaných služeb.
Toto API bylo následně za pomocí technologie Swagger codegenu
použito pro vygenerování kódu java rozhraní TimelineApi,
které bylo možno s~výhodou implementovat java třídou TimelineRestController
spravující HTTP REST operace modulu Timeline.
Swagger codegenem byla vygenerována i~java třída EventDto pro výstupní objekty,
které budou na požádání službou odeslány ve formátu JSON.

Při implemetaci bylo nutno zavést dynamicky vytvářený databázový dotaz,
který bude provoláván vždy při použití služby,
jelikož na jejím vstupu bude proměnlivý EventsFilter objekt pro filtrování dat.
V~rámci java implementace bylo možno s~výhodou použít knihovnu Querydsl,
která umožňuje dynamicky vytvářet databázové dotazy
pro získávání dat dle různých filtrovacíh kritérií.

Po přidání Querydsl knihovny a~příslušného pluginu do projektu,
tato technologie analyzuje v~aplikaci obsažené entiní databázové třídy.
Pro každou entiní třídu vytvoří příslušnou dotazovací třídu,
kterou je pak možné využít pro sestavování vyhledávácích kritérií.

Takto byla vytvořena dotazovací třída QNotification,
která byla následně použita ve třídě NotificationPredicate.
Třida NotificationPredicate poskytuje statickou metodu createBy.
Vstupním parametrem metody createBy je objekt třídy EventsFilter.
Třída EventsFilter obsahuje atributy, jejichž hodnoty jsou předány metodám atributů objektu
dotazovací třídy QNotification pro sestavení vyhledávacích podmínek.
Tyto podmínky se dají přirovnat k~podmínkám klauzule WHERE při vytváření databázového sql dotazu SELECT.
Takto sestavené podmínky je možné zahrnout do vyhledávání s~pomocí objektu třídy BooleanBuilder, taktéž z~knihovny Querydsl.
Objekt třídy BooleanBuilder k~těmto účelům poskytuje metody and nebo or,
díky kterým je možné mezi podmínkami vytvořit stejnojmenné vztahy.
Tento objekt je zároveň výstupem metody createBy a~dalo by se říci, že reprezentuje výslednou sql klauzuli WHERE.

\clearpage

\begin{lstlisting}
public class NotificationPredicate {

    /**
     * Method creates Predicate that represents
     * conditions for DB query by input filter.
     *
     * @param filter contains params for creating query conditions
     * @return querydsl BooleanBuilder
     */
    public static Predicate createBy(EventsFilter filter) {

        BooleanBuilder booleanBuilder = new BooleanBuilder();

        QNotification notification = QNotification.notification;

        // Get without notifications which types are specified
        // in unwanted notification type codes in events filter.
        cutOffNotificationsByNotifTypeCodes(
                filter.getUnwantedNotificationTypeCodes(),
                booleanBuilder, notification);

        // find only notifications of logged in player
        booleanBuilder.and(notification.idPlayer.eq(filter.getIdPlayer()));

        // filter by user wanted notification types
        filterByNotificationTypeCodes(
                filter.getNotificationTypeCodes(),
                booleanBuilder, notification);


        return booleanBuilder;
    }

    private static void cutOffNotificationsByNotifTypeCodes(
            List notificationTypeCodes,
            BooleanBuilder booleanBuilder,
            QNotification notification) {

        if (!CollectionUtils.isEmpty(notificationTypeCodes)) {

            BooleanBuilder codeBooleanBuilder = new BooleanBuilder();
            notificationTypeCodes.forEach(notificationTypeCode ->
                    codeBooleanBuilder.andNot(
                            notification.notificationType()
                                    .code.eq(notificationTypeCode)));

            booleanBuilder.and(codeBooleanBuilder);
        }
    }

    private static void filterByNotificationTypeCodes(
                List notificationTypeCodes,
                BooleanBuilder booleanBuilder,
                QNotification notification) {

        if (!CollectionUtils.isEmpty(notificationTypeCodes)) {

            BooleanBuilder codeBooleanBuilder = new BooleanBuilder();
            notificationTypeCodes.forEach(notificationTypeCode ->
                    codeBooleanBuilder.or(
                            notification.notificationType()
                                    .code.eq(notificationTypeCode)));

            booleanBuilder.and(codeBooleanBuilder);
        }
    }
}
\end{lstlisting}

Výstupní objekt metody createBy je předán na vstup metody findAll rozhraní NotificationRepository,
současně s~objektem pro stránkování, získaného z~objektu třídy EventsFilter.
Po provolání metody findAll s~těmito parametry je vytvořen a~následně spuštěn příslušný databázový dotaz.
Výsledkem je dotažení dat z~databáze, jakožto objektů od entitní třídy Notification.

Metoda je provolávána z~metody getEvents třídy EventsServiceImpl.
Dotažené objekty z~databáze od třídy Notification jsou v~metodě getEvents
přemapovány na posílané EventDto objekty s~použitím příslušných private metod.
Takto upravené a~získané objekty jsou v~závěru odeslány uživateli metodou getPlayerEvents
třídy TimelineRestController prostřednictvím HTTP odpovědi.


\clearpage

\begin{lstlisting}

@Service
@Slf4j
public class EventsServiceImpl implements EventsService {

    @Autowired
    private NotificationRepository notificationRepository;

    ...

    /**
     * Method calls findAll with Predicate
     * created from EventsFilter
     * for retrieving Notification records from DB
     * and map them to Event DTOs.
     *
     * @param filter for filtering events
     * @return List of Event DTOs
     */
    @Override
    public List getEvents(EventsFilter filter) {

        // get query predicate
        Predicate predicate = NotificationPredicate.createBy(filter);

        // call findAll method from lower layer
        // with querydsl Predicate and Spring Data Pageable
        List notifications = Lists
                .newArrayList(notificationRepository
                        .findAll(predicate,
                                filter.getPaggingAndSorting()));

        if (notifications == null) {
            return null;
        }
        return getEventDtoListFromNotifications(notifications);
    }

    ...

\end{lstlisting}


\clearpage

\kapitola{Testování}

Pro testování byly použity volně dostupné programy Postman pro funkční otestování REST služeb
a SoapUI pro zátěžové testy.

Program Postman je možné s výhodou používat pro otestování webových REST služeb.
Prostřednictvím tohoto programu lze vytvářet nejrůznější možné HTTP požadavky
s různými hlavičkami i těli, včetně cookies, bezpečnostních i jiných příznaků.
Tímto způsobem lze nasimulovat například klientovo odeslání formuláře.
Pro vývoj backendových služeb se jedná o ideální nástroj,
který může vývojář použít pro rychlé otestování funkcionality
vyvíjených služeb, jelikož vývojáři backendu nemusejí ztácet čas vytvářením formulářů
a hledáním jiných prostředků pro vyvolání požadavku a navození nejrůznějších stavů.

\vspace{10}

\noindent{\textbf{Ukázka volání registrační služby prostřednictvím aplikace postman:}

\vspace{10}

\noindent{HTTP požadavek zaslán na:}

\noindent{\texttt{http://localhost:8080/rest/security/registration} (POST)}

\vspace{10}

\noindent{Tělo HTTP požadavku (JSON):}

\begin{lstlisting}
{
    "email": "petr.novak@mail.cz",
    "login": "petr.novak",
    "heslo" : "heslo",
    "registrationToken": "1234",
    "idParent": "1"
}
\end{lstlisting}

\vspace{10}

\noindent{Tělo HTTP odpovědi (JSON):}

\begin{lstlisting}
{
    "accessToken": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzUxMiJ9.eyJzdW
                    IiOiIzMyIsImlkSHJhY2EiOiIzMyIsInJvbGEiOiI5NyIsImlzcyI
                    6ImdhbWlmaWthIiwiZXhwIjoxNTg3ODQ5Njk0LCJsb2dpbiI6InBl
                    dHIubm92YWsiLCJqdGkiOiJiNWFiNzgzMi1iOGRkLTRlN2QtYjk3M
                    C00YTA4ZWJlYzZlNmEiLCJlbWFpbCI6InBldHIubm92YWtAbWFpbC
                    5jeiJ9.CQttIGzSXEphm7n-hWhaxMlKUGHEgRpG4uF3k6-z96D2ks
                    _eNE8aqakXHjQclyL1c1VnTT7XBK5hJfEya33v_lBY9lt6GptkdGQ
                    s2eYoUKELxyYjjZ5XtouncqopqMqsHB08DpyeL9D4cE3ERRiT31W7
                    EF1R1y40kR_p1t4HorcwYhRwttoymPIPIF1HYMqf7k6-zbFUsgF0S
                    8PIiYQXkkCooU4kal9os8gKSZBKNV1kdJrc7ucop3TlNryQ-ZDuIP
                    Whfo7XsiJr5-80qSwThyKWc8WARC5CwrEIR1aVj2Mi_LwhqGk2xS8
                    WG9WpbMJuK8GdOCAN339AiIxc5qRdbg"
}
\end{lstlisting}

\vspace{10}

\noindent{Další ukázky funkčního otestování pomocí programu Postman je možné nalézt v kapitole příloh.}

Program SoapUI lze použít pro vytvoření testovacího scénáře,
který se může skládat z většího počtu různých požadavků odeslaných na různé webové služby a
to RESTové i SOAPově založené. Tímto způsobem je možné nasimulovat předpokládanou práci uživatele.
Vývojář si může připravit testovací scénář, který může spouštět pro jednoho i více virtuálních uživatelů a
takto otestovat funkčnost aplikací pro různé stavy i při větším zatížení.
Celkově se jedná o poměrně komplexní program nabízející mnoho různých funkcí
pro různorodé testování webových aplikací, ale i vytváření falešných služeb a simulovat tak chování některých aplikací.
K těmto, i jiným účelům podporuje program skriptovací jazyk groovy.

Pro zátěžové otestování a simulaci práce většího počtu uživatelů byl prostřednictvím
programu SoapUI vytvořen testovací scénář pro otestování služby modulu Timeline.
Testovací scénář se skládá z různých volání služby pro získání událostí přihlášeného uživatele.

\noindent{Kroky testovacího scénáře:}

\begin{enumerate}
\item \textbf{Zobrazit 10 nejnovějších událostí.}
\item \textbf{Zobrazit 3 nejnovější události týkající se pouze dovedností nebo poddovedností.}
\item \textbf{Zobrazit všechny události týkající se splněných herních misí.}
\item \textbf{Zobrazit všechny událostí týkající se dosažení nové úrovně hráče.}
\item \textbf{Zobrazit 3 nejstarší události týkající se splněných úkolů.}
\end{enumerate}


\noindent{Pro každý krok tohoto scénáře byl vytvořen požadavek volaný pod URL adresou
\texttt{http://localhost:9010/timeline/events} se specifickými query parametry následovně:}

\begin{enumerate}
\item \texttt{...?limit=10}
\item \texttt{...?eventTypeCodes=newSkillLevel,newSubskillLevel\&limit=3}
\item \texttt{...?eventTypeCodes=missionCompleted}
\item \texttt{...?eventTypeCodes=newPlayerLevel}
\item \texttt{...?eventTypeCodes=questCompleted\&limit=3\&sortColumns=created}
\end{enumerate}

\clearpage

Po vytvoření těchto požadavků, byl celý scénář spuštěn pro 10 virtuálních uživatelů,
po dobu 60 sekund, s relativně náhodnými prodlevami mezi testovacími kroky v časové délce 1 sekundy.

\vspace{10}

\noindent{Výstupem zátěžového testu je následující tabulka:}

\tabulka{Zátěžový test modulu Timeline}
% \label{odkaz}
\def\arraystretch{1.2}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Testovací krok} & \textbf{průměrná doba [ms]} & \textbf{rychlost přenosu [B/s]} \\
\hline
1 & 436,69 & 7956 \\
\hline
2 & 182,13 & 2266 \\
\hline
3 & 151,21 & 2837 \\
\hline
4 & 149,37 & 2546 \\
\hline
5 & 148,99 & 2863 \\
\hline
Celkově & 1068,41 & 18470 \\
\hline
\end{tabular}
\tabzdroj{Upravené výsledky funkce LoadTest, programu SoapUI}
\endtab

Celkově bylo pro každý testovací krok realizováno 325 volání, přičemž chybných bylo 0.
Průměrnou dobu realizace celého testovacího scénáře 1068,41 ms lze vzhledem k dostupným prostředkům
považovat za uspokojivou.

\kapitola{Závěr}
Hlavním cílem bakalářské práce bylo naimplementovat backendové moduly pro gamifikovaný informační systém.
Backendové moduly pro první funkční prototyp webové aplikace systému byly
úspěšně vytvořeny.
Na základě tohoto prototypu byly postupně vytvořeny
a jsou stále vyvíjeny nové části systému a různá vylepšení.
Prototyp pro modul timeline (historie důležitých událostí hráče) byl taktéž úspěšně vytvořen
a otestován. Aktuálně jsou řešeny jeho možnosti zapojení do stávajícího systému.
Vzhledem k úspěšnému vytvoření v práci popsaných služeb a na základě kladné zpětné vazby od firmy Optimal Energy,
považuji cíl práce za splněný.


Práce na systému probíhají každým dnem a neustále se rozvíjí jeho růrné komponenty a je přidávána nová funkcionalita.
Postupně je vyskládáván poměrně robustní systém, který bude denně používat mnoho pracovníku firmy.
Do budoucna je počítáno s dalším rozvojem, v blízké době budou implementovány nové moduly,
například modul pracující s mapou a geografickou polohou uživatele nebo modul obchodu, zahrnující práci s virtuální herní měnou.
Paralelně jsou vyvíjeny mobilní aplikace pro iOS a Android.
Další plánovanou funkcionalitou je tréninkový simulátor pro pracovníky, pro rozvoj jejich obchodních dovedností,
u kterého se uvažuje o zapojení trendů z oblasti umělé inteligence.
Aktuálně jsou nejvícce upínány síly k vydání nové verze systému, s novým poutavým provedením grafického uživatelského rozhraní,
připravené pro každodenní ostrý provoz.


\begin{literatura}

\citace{codecademyRest}{Codecademy, 2018}
{
\autor{Codecademy}
\nazev{What is REST?} Learn to Code - for Free | Codecademy [online].
Copyright © [cit. 21.04.2020].
Dostupné z:
\\
\texttt{https://www.codecademy.com/articles/what-is-rest}
}

\citace{sapDigitalist}{Digitalist Magazine, 2018}
{
\autor{Digitalist Magazine News on Cloud, Mobile, Big Data, Analytics \& More}
\nazev{Gamification: Turning Work Into Play}
SAP Innovation [online]. Copyright © 2018 SAP SE. All rights reserved.
Dostupné z:
\\
\texttt{https://www.digitalistmag.com/cio-knowledge/2016/10/03/gamification-turning-work-into-play-04509516}
}

\citace{epicwin}{Epic Win, 2019}
{
\autor{Epic Win}
\nazev{Epic Win -- Level-Up Your Life} visual playfulness [online].
Dostupné z:
\texttt{http://www.rexbox.co.uk/epicwin/index.html}
}

\citace{habitica}{Habitica, 2019}
{
\autor{Habitica}
\nazev{Habitica -- Gamify Your Life} [online]
Dostupné z:
\\
\texttt{https://habitica.com/static/home}
}

\citace{javaWorld}{JavaWorld.com, 2020}
{
\autor{JavaWorld}
\nazev{What is Tomcat? The original Java servlet container} | JavaWorld.
Welcome to JavaWorld.com [online]. Copyright © 2020 IDG Communications, Inc.
Dostupné z:
\\
\texttt{https://www.javaworld.com/article/3510460/what-is-apache-tomcat-the-original-java-servlet-container.html}
}

\citace{jwt}{jwt.io, 2020}{
\autor{jwt.io}
\nazev{JSON Web Token Introduction -- jwt.io.} JSON Web Tokens -- jwt.io [online]
Dostupné z:
\\
\texttt{https://jwt.io/introduction/}
}

\citace{kalin}{Martin Kalin, Java Web Services, 2013}
{
\autor{Kalin M.}
\nazev{Java Web Services: Up and Running} | 2. vyd. Sebastopol: O'Reilly, ISBN 978-1-449-36511-0.
}

\citace{gamethinking}{Kim, Game Thinking, 2018}
{
\autor{Kim, A.J. and Koster, R. and Kim, S.}:
\nazev{Game Thinking: Innovate Smarter \&
Drive Deep Engagement with Design Techniques from Hit Games}
Dostupné z: \texttt{https://Gamethinking.io}, 2018. ISBN 9780999788547
}

\citace{maven}{Maven, 2020}{
\autor{Maven}
\nazev{Maven -- Introduction}. Maven -- Welcome to Apache Maven [online].
\\
Dostupné z:
\\
\texttt{https://maven.apache.org/what-is-maven.html}
}

\citace{oracleJava}{Oracle, 2019}{
\autor{Oracle}
\nazev{The Java Language Environment} [online].
Copyright © 2019 Oracle.
\\
Dostupné z:
\\
\texttt{https://www.oracle.com/technetwork/java/intro-141325.html}
}

\citace{oracleJPA}{Oracle, 2013}{
\autor{Oracle}
\nazev{Introduction to the Java Persistence API -- The Java EE 6 Tutorial.}
[online]. Copyright © 2013, Oracle and [cit. 21.04.2020].
Dostupné z:
\\
\texttt{https://www.oracle.com/technetwork/java/intro-141325.html}
}


\citace{springbootDocs}{Spring Boot Reference Documentation, 2020}{
\autor{Pivotal}
\nazev{Spring Boot Reference Documentation} [online]. Dostupné z:
\\
\texttt{https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/}
}

\citace{springFrameworkDocs}{Spring Framework Reference Documentation, 2010}{
\autor{Pivotal}
\nazev{Spring Framework Reference Documentation} [online]. Dostupné z:
\\
\texttt{https://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/htmlsingle/}
}

\citace{springFrameworkCurrentDocs}{Spring Framework Reference Documentation, 2020}{
\autor{Pivotal}
\nazev{Spring Framework Reference Documentation} [online]. Dostupné z:
\\
\texttt{https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/}
}

\citace{podstreleny}{Podstrelený, 2018}{
\autor{Podstrelený Pavol}
\nazev{Vývoj mobilní aplikace s~prvky gamifikace} [online].
Hradec Králové, 2018 [cit. 2018-12-16]. Bakalářská práce. Univerzita~ Hradec~Králové, Fakulta informatiky a~managementu.
Vedoucí práce doc. Ing. Filip Malý, Ph.D..
Dostupné z: \texttt{https://theses.cz/id/9cfx4r}
}

\citace{odinuv}{Popelka O., Lýsek J., odinuv.cz}{
\autor{Popelka O., Lýsek J.}
\nazev{Web Applications}
The Making of a Web Application [online].
Dostupné z:
\\
\texttt{http://odinuv.cz/articles/web-applications/}
}

\citace{sandoval}{Sandoval, 2009}{
\autor{Sandoval J.}
\nazev{RESTful Java Web Services}:
master core REST concepts and create RESTful web services in Java.
Birmingham: Packt Publishing, 2009. 256 s.
ISBN 978-1-84719-646-0.
}

\citace{sapCloudGamification}{SAP Cloud Platform Gamification, 2018}{
\autor{SAP SE}
\nazev{SAP Cloud Platform Gamification}
| SAP Cloud Platform. [online].
Copyright © 2018 SAP SE.
Dostupné z:
\\
\texttt{https://cloudplatform.sap.com/capabilities/product-info.SAP-Cloud-Platform-Gamification.e7f91e3d-24b0-422b-8eef-c74f4aaa0c5d.html\#Features}
}

\citace{swagger}{swagger.io, 2019}{
\autor{SmartBear Software}
\nazev{Get Started With The OpenAPI Specification}
 | Swagger. API Documentation & Design Tools for Teams | Swagger [online].
 Copyright © 2019 SmartBear Software [cit. 03.05.2020].
 Dostupné z:
\\
\texttt{https://swagger.io/solutions/getting-started-with-oas/}
}

\citace{slerka}{Šlerka J., 2012}{
\autor{Šlerka, J.}
\nazev{Gamifikace a širší kontext.} [online]. 2012.
Dostupné z:
\\
\texttt{https://slideslive.com/ladegustationonline/38889586}
}

\citace{technologyAdviceGamification}{technologyadvice.com, 2019}{
\autor{technologyadvice.com}
\nazev{Gamification}
[online]. Dostupné z:
\\
\texttt{https://technologyadvice.com/gamification}
}


\citace{tutorialspointMvc}{Tutorialspoint, 2020}{
\autor{Tutorialspoint}
\nazev{MVC Framework - Introduction} [online]
© Copyright 2020. All Rights Reserved.
Dostupné z:
\\
% TODO: opravit odkaz
% odkaz nefunguje, zalamovani to rozbiji
\texttt{https://www.tutorialspoint.com/mvc\_framework/mvc\_framework\_introduction.htm}
}

\citace{tomcatWikipedia}{en.wikipedia.org, 2020}{
\autor{Wikipedia}
\nazev{Apache Tomcat} -- Wikipedia.[online]
Dostupné z:
\\
\texttt{https://en.wikipedia.org/wiki/Apache\_Tomcat}
}

\citace{xicom}{Xicom, 2020}{
\autor{Xicom}
\nazev{9 Best Reasons To Choose Java For Web Development}
Xicom | Software, Web, Mobile App Development Company [online].
Dostupné z:
\\
\texttt{https://www.xicom.biz/blog/9-best-reasons-to-choose-java-for-web-development/}
}

\citace{octalysis}{Yu-kai Chou, Octalysis}{
\autor{Yu-kai Chou}
\nazev{Octalysis: Complete Gamification Framework}
Learn Gamification with Yu-kai Chou: cheat codes to win the game of life [online].
Dostupné z:
\\
\texttt{https://yukaichou.com/gamification-examples/octalysis-complete-gamification-framework}
}


\end{literatura}

\prilohy

\clearpage

%V kapitole příloh jsou k nahlédnutí vybrané části zdrojových kódů
%webových REST služeb a výstupy z jejich testování.

\priloha{Registrace nového hráče}

\noindent{\textbf{Swagger API (\texttt{Yaml})}}

\begin{lstlisting}
paths:
 /rest/security/registration:
    post:
      tags:
        - Security
      summary: Sluzba dle zadanych hodnot vytvori instanci noveho hrace.
      operationId: postNovyHrac
      parameters:
        - in: body
          name: novyHracDto
          required: true
          schema:
            $ref: '#/definitions/NovyHracDto'
      responses:
        '200':
          description: OK
          schema:
            $ref: '#/definitions/LoginResponseDto'
...
definitions:
# Vstupní DTO
    NovyHracDto:
        type: object
        properties:
          email:
            type: string
          login:
            type: string
          heslo:
            type: string
          registrationToken:
            type: integer
          idParent:
            type: integer
            format: int64
# Výstupní DTO
    LoginResponseDto:
        type: object
        properties:
          accessToken:
            type: string
\end{lstlisting}

\noindent{\textbf{Business logika}}

\begin{lstlisting}

@Service
@Transactional
public class LoginServiceImplementation implements LoginService {

    @Autowired
    private HracRepository hracRepository;

    @Autowired
    private PrihlasovacieUdajeRepository prihlasovacieUdajeRepository;

    ...

    @Override
    public PrihlasovacieUdaje createNewHrac(NovyHracDto novyHracDto) {

        // pokud jiz existuje hrac s takovymi prihl. udaji, vyhodit vyjimku
        if (prihlasovacieUdajeRepository
                        .existsByLoginOrEmail(
                            novyHracDto.getLogin(),
                            novyHracDto.getEmail())) {
            throw new ErrorCodeException(
                            ErrorCodeEnum.NEPLATNA_REGISTRACE,
                            "Uzivatel s temito prihasovacimi udaji jiz existuje.");
        }

        PrihlasovacieUdaje prihlasovacieUdaje = new PrihlasovacieUdaje();
        prihlasovacieUdaje.setLogin(novyHracDto.getLogin());
        prihlasovacieUdaje.setEmail(novyHracDto.getEmail());

        // nastavit zahashovane heslo dle algoritmu SHA256
        prihlasovacieUdaje.setPassword(Hashing.sha256().hashString(
                novyHracDto.getHeslo(), StandardCharsets.UTF_8).toString());

        // provolat inicializaci Hrace a~provazat s~jeho ID
        prihlasovacieUdaje.setIdHraca(initHrac(novyHracDto).getId());

        // uzivatel se prihlasuje poprve
        prihlasovacieUdaje.setPrvePrihlasenie(true);
        prihlasovacieUdaje.setIdRola(ID_ROLE_STANDARD);
        return prihlasovacieUdajeRepository.save(prihlasovacieUdaje);
    }

    ...

    private Hrac initHrac(NovyHracDto novyHracDto) {
        Hrac hrac = new Hrac();
        hrac.setOsobneUdaje(initOsobniUdaje());
        hrac.setUdajePostavy(initUdajePostavy());
        hrac.setNastavenia(initNastaveni());
        // set ID nadrizeneho
        hrac.setIdParent(novyHracDto.getIdParent());
        return hracRepository.save(hrac);
    }
\end{lstlisting}

\clearpage

\noindent{\textbf{Controller}}

\begin{lstlisting}

@RestController
@RequestMapping(
        value = "/rest/security",
        produces = {"application/json"},
        consumes = {"application/json"})
public class LoginRestController implements SecurityApi {

    @Autowired
    private LoginService loginService;

    @Autowired
    private JwtTokenService jwtTokenService;

    ...

    /**
     * Dle vstupujiciho DTO metoda vytvori noveho hrace
     * a~odesle zpet pristupovy token.
     *
     * @param novyHracDto prichozi DTO noveho hrace,
     * ktery ma byt registrovan
     *
     * @return Metoda vraci LoginResponseDTO
     * obsahujici pristupovy token
     */
    @Override
    @PostMapping(value = "/registration")
    public ResponseEntity postNovyHrac(
            @RequestBody NovyHracDto novyHracDto) {

        JwtToken jwtToken = jwtTokenService.createJwtToken(
                loginService.createNewHrac(novyHracDto));

        LoginResponseDto loginResponseDto = new LoginResponseDto();
        loginResponseDto.setAccessToken(jwtToken.getToken());

        return new ResponseEntity<>(loginResponseDto, HttpStatus.OK);
    }

    ...

\end{lstlisting}

\clearpage

\noindent{\textbf{Funkční test (Postman)}}

\vspace{10}

\noindent{HTTP požadavek zaslán na:}

\noindent{\texttt{http://localhost:8080/rest/security/registration} (POST)}

\vspace{10}

\noindent{Tělo HTTP požadavku (JSON):}

\begin{lstlisting}
{
    "email": "petr.novak@mail.cz",
    "login": "petr.novak",
    "heslo" : "heslo",
    "registrationToken": "1234",
    "idParent": "1"
}
\end{lstlisting}

\vspace{10}

\noindent{Tělo HTTP odpovědi (JSON):}

\begin{lstlisting}
{
    "accessToken": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzUxMiJ9.eyJzdW
    IiOiIzMyIsImlkSHJhY2EiOiIzMyIsInJvbGEiOiI5NyIsImlzcyI
    6ImdhbWlmaWthIiwiZXhwIjoxNTg3ODQ5Njk0LCJsb2dpbiI6InBl
    dHIubm92YWsiLCJqdGkiOiJiNWFiNzgzMi1iOGRkLTRlN2QtYjk3M
    C00YTA4ZWJlYzZlNmEiLCJlbWFpbCI6InBldHIubm92YWtAbWFpbC
    5jeiJ9.CQttIGzSXEphm7n-hWhaxMlKUGHEgRpG4uF3k6-z96D2ks
    _eNE8aqakXHjQclyL1c1VnTT7XBK5hJfEya33v_lBY9lt6GptkdGQ
    s2eYoUKELxyYjjZ5XtouncqopqMqsHB08DpyeL9D4cE3ERRiT31W7
    EF1R1y40kR_p1t4HorcwYhRwttoymPIPIF1HYMqf7k6-zbFUsgF0S
    8PIiYQXkkCooU4kal9os8gKSZBKNV1kdJrc7ucop3TlNryQ-ZDuIP
    Whfo7XsiJr5-80qSwThyKWc8WARC5CwrEIR1aVj2Mi_LwhqGk2xS8
    WG9WpbMJuK8GdOCAN339AiIxc5qRdbg"
}
\end{lstlisting}

\priloha{Potvrzení prvního přihlášení}

\noindent{\textbf{Swagger API (\texttt{Yaml})}}

\begin{lstlisting}

...

paths:
    /hrac/prvni-prihlaseni:
        put:
          tags:
            - Hrac
          summary: Sluzba zmeni hodnotu prvniho prihlaseni prihlaseneho uzivatele.
          operationId: putPrvniPrihlaseni
          parameters:
            - in: body
              name: editacePrvnihoPrihlaseni
              required: true
              schema:
                $ref: '#/definitions/PrvniPrihlaseniDto'
          responses:
            '200':
              description: OK

...

definitions:
  PrvniPrihlaseniDto:
    type: object
    properties:
      prvniPrihlaseni:
        type: boolean

...

\end{lstlisting}

\clearpage

\noindent{\textbf{Business logika}}

\begin{lstlisting}
@Service
public class HracServiceImplementation implements HracService {

@Autowired
PrihlasovacieUdajeRepository prihlasovacieUdajeRepository;

...

    /**
     * Metoda upravi hodnotu prvniho prihlaseni, dle vstupniho DTO,
     * objektu prihlasovacich udaju, dohledaneho dle ID hrace.
     *
     * @param hracId ID prihlaseneho uzivatele
     * @param prvniPrihlaseniDto DTO s~priznakem prvniho prihlaseni
     * @return aktualizovany objekt prvniho prihlaseni
     */
    @Override
    @Transactional
    public PrihlasovacieUdaje editPrvniPrihlaseni(
                                    Long hracId,
                                    PrvniPrihlaseniDto prvniPrihlaseniDto) {

        Optional prihlasovacieUdajeOptinal
                = prihlasovacieUdajeRepository.findByHracId(hracId);

        if (!prihlasovacieUdajeOptinal.isPresent()) {
            return null;
        }

        PrihlasovacieUdaje prihlasovaciUdajeToEdit
                    = prihlasovacieUdajeOptinal.get();
        prihlasovaciUdajeToEdit.setPrvePrihlasenie(
                prvniPrihlaseniDto.getPrvniPrihlaseni());
        return prihlasovacieUdajeRepository.save(prihlasovaciUdajeToEdit);
    }

...
\end{lstlisting}

\clearpage

\noindent{\textbf{Controller}}

\begin{lstlisting}
@RestController
@RequestMapping(
        value = "/rest/hrac", produces = {"application/json"})
public class HracRestController
        extends AbstractJwtRestController implements HracApi {

    @Autowired
    private HracService hracService;

    ...

    /**
     * Metoda provola prislusnou service metodu
     * pro zmenu hodnoty prvnihoPrihlaseni
     * v~prihlasovacich udajich prihlaseneho hrace.
     *
     * @param prvniPrihlaseniDto jednoduche DTO
     *        obsahujici boolean prvnihoPrihlaseni
     *
     * @return prislusnou HTTP odpoved
     */
    @Override
    @PutMapping(
            value="/prvni-prihlaseni",
            consumes = {"application/json"})
    public ResponseEntity putPrvniPrihlaseni(
            @RequestBody PrvniPrihlaseniDto prvniPrihlaseniDto) {

        // ziskat ID hrace z~tokenu
        Long hracId = Long.parseLong(getValidJwtToken().getId());

        // provolat metodu prislusne sluzby z~nizsi service vrstvy
        PrihlasovacieUdaje prihlasovacieUdaje
            = hracService.editPrvniPrihlaseni(
                            hracId, prvniPrihlaseniDto);

        if (prihlasovacieUdaje == null) {
            LOG.error("Prihlasovaci udaje pro ID hrace:
                                {} nenalezeny.", hracId);
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
        return new ResponseEntity<>(HttpStatus.OK);
    }
\end{lstlisting}

\clearpage

\noindent{\textbf{Funkční test (Postman)}}

\vspace{10}

\noindent{HTTP požadavek zaslán na:}

\noindent{\texttt{http://localhost:8081/rest/hrac/prvni-prihlaseni} (PUT)}

\vspace{10}

\noindent{Tělo HTTP požadavku (JSON):}

\begin{lstlisting}
{
    "prvniPrihlaseni": "false"
}
\end{lstlisting}

\vspace{10}

\noindent{Odesláno s příznakem \texttt{Authorization}, s hodnoutou \texttt{JWT tokenu} v hlavičce HTTP požadavku.}

\vspace{10}

\noindent{HTTP odpověď -- HTTP Status: 200 OK, bez těla odpovědi.}

\priloha{Inicializace dovednostního stromu hráče}

\noindent{\textbf{Swagger API (\texttt{Yaml})}}

\begin{lstlisting}

...

paths:
  /dovednosti/inicializace:
    post:
      tags:
        - dovednosti
      summary: Sluzba inicializuje dovednosti noveho hrace.
      operationId: initDovednostiHrace
      responses:
        '200':
          description: OK

...

\end{lstlisting}

\vspace{50}

\noindent{\textbf{Business logika}}

\begin{lstlisting}
@Service
public class KategorieDovednostiServiceImplementation
                    implements KategorieDovednostiService {

    @Autowired
    private KategorieDovednostiRepository kategoriaDovednostiRepository;
    @Autowired
    private TypKategorieDovednostiRepository
                                typKategorieDovednostiRepository;
    @Autowired
    private TypDovednostiRepository typDovednostiRepository;
    @Autowired
    private DovednostRepository dovednostRepository;

    ...

    @Override
    @Transactional
    public void initStromDovednosti(Long hracId) {

        Iterable kategorieDovednostiIterable
                = initKategorieDovednostiHrace(hracId);

        initDovednostiHrace(kategorieDovednostiIterable);

    }

    private List initKategorieDovednostiHrace(Long hracId) {

        // ziskat seznam vsech typu kategorii dovednosti
        Iterable typyKategorieDovednosti
                = typKategorieDovednostiRepository.findAll();

        List kategoriaDovednostiList
                = new ArrayList<>();

        // pro kazdy typ kategorie dovednosti
        // vytvorit hraci instanci kategorie dovednosti
        typyKategorieDovednosti.forEach(TypKategorieDovednosti -> {
                    KategoriaDovednosti kategoriaDovednosti =
                            createKategorieDovednosti(hracId, TypKategorieDovednosti);
                    kategoriaDovednostiList.add(kategoriaDovednosti);
        });

        return kategoriaDovednostiList;
    }

    private KategoriaDovednosti createKategorieDovednosti(
            Long hracId, TypKategorieDovednosti typKategorieDovednosti) {

        KategoriaDovednosti kategoriaDovednosti = new KategoriaDovednosti();
        kategoriaDovednosti.setTypKategorieDovednosti(typKategorieDovednosti);
        kategoriaDovednosti.setIdHraca(hracId);
        kategoriaDovednosti.setZiskaneSkusenosti(0);
        kategoriaDovednosti.setUroven(0);
        kategoriaDovednosti.setAktivita(0);
        return kategoriaDovednostiRepository.save(kategoriaDovednosti);
    }

    private void initDovednostiHrace(Iterable kategorieDovednostiIterable) {
        kategorieDovednostiIterable.forEach(
                KategoriaDovednosti -> createAllDovednostiKategorie(
                        KategoriaDovednosti));
    }

    private void createAllDovednostiKategorie(
            KategoriaDovednosti kategorieDovednosti) {

        // vyhledat typy dovednosti dle typu kategorie dovednosti
        Iterable typyDovednostiIterable = typDovednostiRepository
                .findByTypKategorieDovednosti(
                        kategorieDovednosti.getTypKategorieDovednosti());

        // vytvorit instanci dovednosti od kazdeho typu dovednosti
        // prislusne kategorie dovednosti
        typyDovednostiIterable.forEach(
                TypDovednosti -> createDovednost(
                        kategorieDovednosti, TypDovednosti));
    }

    private Dovednost createDovednost(
            KategoriaDovednosti kategoriaDovednosti,
            TypDovednosti typDovednosti) {

        Dovednost dovednost = new Dovednost();
        dovednost.setKategoriaDovednosti(kategoriaDovednosti);
        dovednost.setTypDovednosti(typDovednosti);
        dovednost.setUroven(0);
        dovednost.setSkusenosti(0);
        dovednost.setAktivita(0);
        return dovednostRepository.save(dovednost);
    }


\end{lstlisting}

\clearpage

\noindent{\textbf{Controller}}

\begin{lstlisting}
@RestController
@RequestMapping(value = "/rest/dovednosti",
                produces = {"application/json"})
public class DovednostiRestController
        extends AbstractJwtRestController
        implements DovednostiApi {

    @Autowired
    private KategorieDovednostiService kategoriaDovednostiService;

    ...

    /**
     * Metoda provola inicializaci
     * dovednostniho stromu noveho hrace.
     *
     */
    @Override
    @PostMapping(
            value = "/inicializace",
            consumes = {"application/json"})
    public ResponseEntity initDovednostiHrace() {

        // ziskat ID hrace z~JWT tokenu
        Long hracId = Long.parseLong(getValidJwtToken().getSubject());

        // provolat prislusnou metodu sluzby z~nizsi vrstvy
        kategoriaDovednostiService.initStromDovednosti(hracId);

        return new ResponseEntity<>(HttpStatus.OK);
    }

    ...

\end{lstlisting}

\clearpage

\noindent{\textbf{Funkční test (Postman)}}

\vspace{10}

\noindent{HTTP požadavek zaslán na:}

\noindent{\texttt{http://localhost:8082/rest/dovednosti} (POST)}

\vspace{10}

\noindent{Odesláno s příznakem \texttt{Authorization}, s hodnoutou \texttt{JWT tokenu}
v hlavičce HTTP požadavku, bez těla požadavku.}

\vspace{10}

\noindent{HTTP odpověď -- HTTP Status: 200 OK, bez těla odpovědi.}

\priloha{Inicializace úkolů nového hráče}

\noindent{\textbf{Swagger API (\texttt{Yaml})}}

\begin{lstlisting}

...

paths:
  /questy/inicializace:
    post:
      tags:
        - questy
      summary: Sluzba inicializuje questy noveho hrace.
      operationId: initQuestyHrace
      responses:
        '200':
          description: OK

...

\end{lstlisting}

\vspace{50}

\noindent{\textbf{Business logika}}

\begin{lstlisting}
@Service
public class QuestServiceImplementation implements QuestService{

    @Autowired
    private QuestRepository questRepository;

    @Autowired
    private TypQuestuRepository typQuestuRepository;

    ...

    @Override
    @Transactional
    public Quest createQuestForNewPlayer(Long hracId) {

        // ziskat typ prvniho questu
        Optional typPrvnihoQuestu
                = typQuestuRepository
                    .findByKod(KOD_TYPU_PRVNIHO_QUESTU);

        // pokud nenalezen, vrat null
        if (!typPrvnihoQuestu.isPresent()) {
            return null;
        }

        // vytvorit prvni quest noveho hrace
        return createQuest(hracId, typPrvnihoQuestu.get(),
                STAV_QUESTU_PRIPRAVENY);
    }

    private Quest createQuest(Long hracId,
                              TypQuestu typQuestu,
                              Long stavQuestuId) {

        Quest quest = new Quest();
        quest.setTypQuestu(typQuestu);
        quest.setIdHraca(hracId);
        quest.setIdStavQuestu(stavQuestuId);
        quest.setDatumVzniku(new Date());
        return questRepository.save(quest);
    }

    ...

\end{lstlisting}

\clearpage

\noindent{\textbf{Controller}}

\begin{lstlisting}
@RestController
@RequestMapping(
        value = "/rest/questy",
        produces = {"application/json"})
public class QuestyRestController
        extends AbstractJwtRestController implements QuestyApi {

    @Autowired
    private QuestService questService;

    ...

    /**
     * Metoda provola prislusne service metody pro
     * vytvoreni instance prvniho questu noveho hrace.
     *
     * @return prislusnou HTTP odpoved
     */
    @Override
    @PostMapping(value = "/inicializace")
    public ResponseEntity initQuestyHrace() {

        // provovolat service metodu nizsi vrstvy
        Quest quest = questService.createQuestForNewPlayer(
               Long.parseLong(getValidJwtToken().getSubject()));

        if (quest == null) {
            LOG.error("Nenalezen prislusny typ questu!");
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }

        return new ResponseEntity<>(HttpStatus.OK);
    }
    ...

\end{lstlisting}

\clearpage

\noindent{\textbf{Funkční test (Postman)}}

\vspace{10}

\noindent{HTTP požadavek zaslán na:}

\noindent{\texttt{http://localhost:8083/rest/questy/inicializace} (POST)}

\vspace{10}

\noindent{Odesláno s příznakem \texttt{Authorization}, s hodnoutou \texttt{JWT tokenu}
v hlavičce HTTP požadavku, bez těla požadavku.}

\vspace{10}

\noindent{HTTP odpověď -- HTTP Status: 200 OK, bez těla odpovědi.}

\priloha{Získání důležitých událostí přihlášeného hráče}

\noindent{\textbf{Swagger API (\texttt{Yaml})}}

\begin{lstlisting}
paths:
  /timeline/events:
    get:
      ...
      parameters:
        - in: query
          name: eventTypeCodes
          type: array
          items:
            type: string
        - in: query
          name: limit
          type: integer
        - in: query
          name: offset
          type: integer
        - in: query
          name: sortColumns
          type: array
          items:
            type: string
      responses:
        '200':
          description: OK
          schema:
            type: array
            items:
              $ref: '#/definitions/EventDto'
definitions:
  EventDto:
    type: object
    properties:
      idRoute:
        type: string
      title:
        type: string
      eventTypeCode:
        type: string
      created:
        type: string
\end{lstlisting}

\clearpage

\noindent{\textbf{Filtrovací databázový predikát -- použití knihovny QueryDSL}}

\begin{lstlisting}
public class NotificationPredicate {

    /**
     * Method creates Predicate that represents
     * conditions for DB query by input filter.
     *
     * @param filter contains params for creating query conditions
     * @return querydsl BooleanBuilder
     */
    public static Predicate createBy(EventsFilter filter) {

        BooleanBuilder booleanBuilder = new BooleanBuilder();

        QNotification notification = QNotification.notification;

        // Get without notifications which types are specified
        // in unwanted notification type codes in events filter.
        cutOffNotificationsByNotifTypeCodes(
                filter.getUnwantedNotificationTypeCodes(),
                booleanBuilder, notification);

        // find only notifications of logged in player
        booleanBuilder.and(notification.idPlayer.eq(filter.getIdPlayer()));

        // filter by user wanted notification types
        filterByNotificationTypeCodes(
                filter.getNotificationTypeCodes(),
                booleanBuilder, notification);


        return booleanBuilder;
    }

    private static void cutOffNotificationsByNotifTypeCodes(
            List notificationTypeCodes,
            BooleanBuilder booleanBuilder,
            QNotification notification) {

        if (!CollectionUtils.isEmpty(notificationTypeCodes)) {

            BooleanBuilder codeBooleanBuilder = new BooleanBuilder();
            notificationTypeCodes.forEach(notificationTypeCode ->
                    codeBooleanBuilder.andNot(
                            notification.notificationType()
                                    .code.eq(notificationTypeCode)));

            booleanBuilder.and(codeBooleanBuilder);
        }
    }

    private static void filterByNotificationTypeCodes(
                List notificationTypeCodes,
                BooleanBuilder booleanBuilder,
                QNotification notification) {

        if (!CollectionUtils.isEmpty(notificationTypeCodes)) {

            BooleanBuilder codeBooleanBuilder = new BooleanBuilder();
            notificationTypeCodes.forEach(notificationTypeCode ->
                    codeBooleanBuilder.or(
                            notification.notificationType()
                                    .code.eq(notificationTypeCode)));

            booleanBuilder.and(codeBooleanBuilder);
        }
    }
}
\end{lstlisting}

\clearpage

\noindent{\textbf{Business logika}}

\begin{lstlisting}

@Service
@Slf4j
public class EventsServiceImpl implements EventsService {

    @Autowired
    private NotificationRepository notificationRepository;

    ...

    /**
     * Method calls findAll with Predicate
     * created from EventsFilter
     * for retrieving Notification records from DB
     * and map them to Event DTOs.
     *
     * @param filter for filtering events
     * @return List of Event DTOs
     */
    @Override
    public List getEvents(EventsFilter filter) {

        // get query predicate
        Predicate predicate = NotificationPredicate.createBy(filter);

        // call findAll method from lower layer
        // with querydsl Predicate and Spring Data Pageable
        List notifications = Lists
                .newArrayList(notificationRepository
                        .findAll(predicate,
                                filter.getPaggingAndSorting()));

        if (notifications == null) {
            return null;
        }
        return getEventDtoListFromNotifications(notifications);
    }

    ...

\end{lstlisting}

\clearpage

\noindent{\textbf{Controller}}

\begin{lstlisting}
@Slf4j
@RestController
@RequestMapping(path = "timeline", produces = {"application/json"})
public class TimelineRestController extends AbstractJwtDecoderController
                                    implements TimelineApi {

    @Autowired
    private EventsService eventsService;

    /**
     * Method calls appropriate service methods for retrieving
     * player events.
     *
     * @param eventTypeCodes Notification Type's~codes
     *        for filtering events
     * @param limit
     * @param offset
     * @return List of Event's~DTOs
     */
    @Override
    @GetMapping("/events")
    public ResponseEntity> getPlayerEvents(
                                @Valid List eventTypeCodes,
                                @Valid Integer limit,
                                @Valid Integer offset,
                                @Valis List sortColumns) {

        EventsFilter eventsFilter = new EventsFilter(getTokenSubject(),
                eventTypeCodes, limit, offset);

        log.info("Calling getEvents with filter: {}", eventsFilter.toString());
        // calling service method from lower layer
        List eventDtoList = eventsService.getEvents(eventsFilter);
        return new ResponseEntity<>(eventDtoList, HttpStatus.OK);
    }

    ...
}
\end{lstlisting}

\clearpage

\noindent{\textbf{Funkční test (Postman)}}

\vspace{10}

\noindent{HTTP požadavek zaslán na:}

\noindent{\texttt{http://localhost:9010/timeline/events} (GET)}

\vspace{10}

\noindent{Odesláno s:}

\begin{itemize}
\item \texttt{query} parametry:
        \begin{itemize}
            \item \texttt{eventTypeCodes=newSkillLevel,newSubskillLevel} --
                    pro vyhledání událostí týkajících
                    se pouze nově dosažených dovednostních úrovní hráče
            \item \texttt{limit=3} -- pro omezení počtu výstupních položek na 3
        \end{itemize}

\item příznakem \texttt{Authorization}, s hodnoutou \texttt{JWT tokenu}v hlavičce HTTP požadavku}
\end{itemize}

\vspace{10}

\noindent{Tělo HTTP odpovědi (JSON):}

\begin{lstlisting}
[
    {
        "idRoute": "46",
        "title": "Dosazen level 2 dovednosti Obchod",
        "eventTypeCode": "newSkillLevel",
        "created": "2020-02-04 17:36:18.0"
    },
    {
        "idRoute": "122",
        "title": "Dosazen level 2 poddovednosti Kontaktovani klientu",
        "eventTypeCode": "newSubskillLevel",
        "created": "2020-02-04 17:36:18.0"
    },
    {
        "idRoute": "119",
        "title": "Dosazen level 2 poddovednosti Domacnosti",
        "eventTypeCode": "newSubskillLevel",
        "created": "2020-01-28 16:53:15.0"
    }
]
\end{lstlisting}

\end{document}
